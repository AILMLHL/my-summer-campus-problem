# 夏令营面试复习

https://blog.csdn.net/qq_34767784/article/details/106360514

## 数据结构

### 1. O(n)的大O是什么意思？什么是时间复杂度? ★★★

O(n)中，大O表示的是最坏情况下的时间复杂度，表示函数运行的上界；
Ω表示最好情况下的时间复杂度，表示函数运行的下界；
θ表示了函数运行的上下界

**时间复杂度**:指程序执行所需要的计算工作量，它可以定性描述程序的运行时间。

**空间复杂度**:程序在运行过程中临时占用存储空间大小的量度

### 2. 比较线性存储结构和链式存储结构（顺序表和链表）★★★

线性表的顺序存储称为顺序表，特点是表中元素的逻辑顺序与物理顺序相同。

线性表的链式存储称为链表，他不需要使用地址连续的存储单元，即不要求逻辑顺序相邻的元素，物理顺序也相邻。

1. **存取方式**:顺序表可以顺序存取，也可以随机存取；链表只能从表头开始顺序存取元素；

2. **逻辑结构与物理结构**:采用顺序存储时，逻辑上相邻的元素，对应的物理存储位置也相邻；采用链式存储时，逻辑上相邻的元素，物理存储位置不一定相邻，对应的逻辑关系通过指针链接来表示。

3. **查找，插入和删除**:
   
   对于按值查找，链表查找时间复杂度为O(n)；顺序表无序时，时间复杂度均为O(n)，有序时，采用二分法查找时间复杂度为O(log n)
   
   对于按序号查找，顺序表支持随机访问，时间复杂度为O(1)；链表的平均时间复杂度为O(n)。顺序表的插入删除操作需要花费很多时间在移动元素上，平均时间复杂度为O(n)，而链表只需要修改节点相关的指针域，时间复杂度为O(1)。

### 3. 栈和队列的区别和内存结构★★★

**栈**

1. **定义**:是一种后进先出的数据结构，只允许在表的一端进行插入和删除的线性表，允许插入和删除的一端叫做栈顶，不允许插入和删除的一端叫做栈底。

2. 栈的存储结构通常分为基于数组的顺序存储结构和基于链表的链式存储结构，

3. 顺序栈的内存结构:存放栈中元素的数组. 栈顶指针. 最大容纳元素个数

4. 链式栈的内存结构:栈顶指针

**队列**

1. **定义**:是一种先进先出的数据结构，只允许在表的一端插入，在另一端删除的线性表。允许插入元素的一端称为队尾，允许删除的一端称为队首。
2. 队列的存储结构通常分为基于数组的顺序存储结构和基于链表的链式存储结构。
3. 顺序存储结构利用一个一维数组作为存储结构，并设置头指针和尾指针两个指针来指示队首和队尾的位置。
4. 链式队列由队首指针和队尾指针构成。

### 4. 有一个循环队列Q，里面的编号是0到n-1，头尾指针分别是f，p，现在求Q中元素的个数？★★

(p - f + n) % n

### 5. 如何区分循环队列是队空还是队满？★★★

front表示队头指针（指向队列内首元素）

rear表示队尾指针（指向队列内尾元素的下一个位置）

m表示队列的容量（包括那个留空的位置）

<img src="/Users/userli/Desktop/imgs_typora/image-20220605225037628.png" alt="image-20220605225037628" style="zoom: 33%;" />

队空:front = rear

队满:front = (rear + 1) % m

### 6. 堆. 大顶堆. 小顶堆实现及应用 ★★

**堆是用完全二叉树的结构来维护的一维数组**。堆的父结点的键值或索引总是小于（或者大于）它的子节点，大于的话为大顶堆，小于的话为小顶堆

按照堆的特点可以把堆分为**大顶堆**和**小顶堆**

1. 大顶堆:每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列；
2. 小顶堆:每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列；

堆的这种特性非常的有用，堆常常被当做**优先队列**使用，因为可以快速的访问到“最重要”的元素

**堆排序**是指利用堆这种数据结构所设计的一种排序算法。堆排序的平均时间复杂度为 Ο(nlogn)。

**堆和普通树的区别**

1. **内存占用**:普通树占用的内存空间比它们存储的数据要多。你必须为节点对象以及左/右子节点指针分配额外的内存。堆仅仅使用数组，且不使用指针（可以使用普通树来模拟堆，但空间浪费比较大）
2. **平衡**:二叉搜索树必须是“平衡”的情况下，其大部分操作的复杂度才能达到**O(nlog2n)**。你可以按任意顺序位置插入/删除数据，或者使用 红黑树，但是在堆中实际上不需要整棵树都是有序的。我们只需要满足对属性即可，所以在堆中平衡不是问题。因为堆中数据的组织方式可以保证**O(nlog2n)** 的性能
3. **搜索**:在二叉树中搜索会很快，但是在堆中搜索会很慢。在堆中搜索不是第一优先级，因为使用堆的目的是将最大（或者最小）的节点放在最前面，从而快速的进行相关插入. 删除操作

### 7. 哈希表的概念. 构造方法. 哈希有几种类型？哈希冲突的解决办法？★★★★

https://blog.csdn.net/qq_31828515/article/details/56682501

哈希表，是根据键直接访问在内存储存位置的数据结构。它通过散列函数，将所需查询的数据映射到表中一个位置来让人访问，这加快了查找速度。存放记录的数组称做散列表。

hash表的实现主要包括**构造哈希**和**处理哈希冲突**两个方面:对于构造哈希来说，主要包括**直接地址法**. **平方取中法. 除留余数法**。对于处理哈希冲突来说，最常用的处理冲突的方法有**开放定址法. 再哈希法. 链地址法.**等方法。

当哈希表关键字集合很大时，关键字值不同的元素可能会映象到哈希表的同一地址上，这样的现象称为**哈希冲突**。目前常用的解决哈希冲突的方法如下:

1. **开放定址法**:  在插入一个元素的时候，先通过哈希函数进行判断，若是发生哈希冲突，就以当前地址为基准，根据再寻址的方法（线性探测，平方探测，伪随机探测），去寻找下一个地址。
2. **再哈希法**:当发生哈希冲突时使用另一个哈希函数计算地址值，直到冲突不再发生。这种方法不易产生聚集，但是增加计算时间，同时需要准备许多哈希函数。
3. **链地址法**:将所有哈希值相同的Key通过链表存储。key按顺序插入到链表中

影响产生冲突多少有以下三个因素:

1. 散列函数是否均匀；
2. 处理冲突的方法；
3. 散列表的载荷因子

### 8. 判断链表是否有环（非常重要！）★★★★★★★

快慢指针:从头开始设置两个指针，快指针每次走2步，慢指针每次走1步，如果快指针先碰到尾，则无环，否则两个指针之后一定会重合，则有环。

判断链表是否有环以及环的位置:https://leetcode-cn.com/problems/linked-list-cycle-ii/

### 9. 平衡二叉树. 二叉排序树. 完全二叉树. 二叉搜索树的区别及如何构造★★★

完全二叉树的每一个节点都与高度为 h 的满二叉树的 1 - n 编号一一对应，完全二叉树前 n / 2 个元素为非叶子元素

二叉搜索树即二叉排序树，二叉排序树每一个节点都是用于排序的关键码，左子树所有节点关键码都小于根节点的关键码，右子树的所有关键码都大于根节点的关键码，其中，左右子树都是二叉树。对一棵二叉排序树进行中序遍历就可以得到关键码从小到大的排列。

二叉排序树的构造方法主要执行插入操作，进行插入之前必须先检查是否该节点的关键码已经在树中存在，也就是要先查找，假如查找成功，不执行任何操作，假如搜索不成功，就在搜索停止的地方添加新元素。

平衡二叉树是一种二叉搜索树，它的左右子树高度差的绝对值不超过1。构造一棵平衡二叉树仍然是通过插入节点的方式，每插入一个结点，都应该检查平衡因子，并通过旋转操作使之平衡化。

### 10. 如何由遍历序列构造一颗二叉树？/已知先序序列和后序序列能否重现二叉树？（笔试经常考）★★★

若是中序和先序或者中序和后序，则可。

首先先序中我们可以锁定当前第一个点为根，中序中找到这个点，去把子树分割成左子树和右子树两个部分，再依次递归下去即可。

先序和中序不能重现一颗唯一的二叉树。但有可能找出满足此的二叉树。

### 11. B树是什么?在数据库中有什么应用？（B数和B+树的区别）★★★

> B-树，又叫多路平衡查找树，
> 
> https://www.jianshu.com/p/ace3cd6526c4

在数据库查询中，用树存储数据。树有多少层，就意味着要读多少次磁盘IO。所以树的高度越矮，就意味着查询数据时，需要读IO的次数就越少。当数据量大的时候，用AVL树存的话，其高度相对较大为 log n，那么读取数据的IO次数也会多，并且插入删除数据时AVL树旋转也需要开销。

B树相对于平衡二叉树的不同是，每个节点包含的关键字增多了，是一颗多叉树，这样树的高度降低，就意味着查询数据时，需要读IO的次数就越少。在B树应用到数据库中的时候，数据库充分利用了磁盘块的原理（磁盘数据存储是采用块的形式存储的，每个块的大小为4K，每次IO进行数据读取时，同一个磁盘块的数据可以一次性读取出来）把节点大小限制和充分使用在磁盘快大小范围；把树的节点关键字增多后树的层级比原来的二叉树少了，减少数据查找的次数和复杂度，提升了查询效率;

B-树有如下特点:

1. 所有键值分布在整颗树中；
2. 任何一个关键字只出现在一个结点中；
3. 搜索有可能在非叶子结点结束（最好情况O(1)就能找到数据）；
4. 在关键字全集内做一次查找,性能逼近二分查找；

B树的缺点是:不利于范围查找(区间查找)，如果要找 0~100的索引值，那么B树需要多次从根结点开始逐个查找。

B+树是B-树的变体，也是一种多路平衡查找树, 它与 B- 树的不同之处在于:

1. 所有关键字存储在叶子节点出现, 内部节点（非叶子节点）并不存储真正的 data
2. 为所有叶子结点增加了一个链指针，叶子本身按索引值的大小从小到大进行排序。即这条链表是 从小到大的。因此可以直接通过遍历链表实现范围查找。

<img src="/Users/userli/Desktop/imgs_typora/image-20220629214013691.png" alt="image-20220629214013691" style="zoom:50%;" />

B+树优点:https://zhuanlan.zhihu.com/p/27700617

### 12. 红黑树原理是什么？建立过程？★★★

https://www.cnblogs.com/skywang12345/p/3245399.html

**红黑树的特性**:

1. **每个节点或者是黑色，或者是红色。**
2. **根节点是黑色。**
3. **每个叶子节点（NIL）是黑色。 [注意:这里叶子节点，是指为空(NIL或NULL)的叶子节点！]**
4. **如果一个节点是红色的，则它的子节点必须是黑色的。**
5. **从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。**

**红黑树添加**:

1. **将红黑树当作一颗二叉查找树，将节点插入**
2. **将插入的节点着色为"红色"**
3. **通过一系列的旋转或着色等操作，使之重新成为一颗红黑树**

**红黑树删除**

1. **将红黑树当作一颗二叉查找树，将节点删除**
2. **通过"旋转和重新着色"等一系列来修正该树，使之重新成为一棵红黑树**

### 13. 二分搜索和单纯的线性搜索的区别/时间复杂度★★★

**顺序查找**:遍历线性表，逐个检查关键字是否满足给定条件

> 二分查找算法是一种在有序数组中查找某一特定元素的搜索算法。
> 
> 搜素过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜 素过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组 为空，则代表找不到。这种搜索算法每一次比较都使搜索范围缩小一半。折半搜索每次把搜索区域减少一半，时间复杂度为Ο(logn) 。

**二分查找**: 仅适用于有序的顺序表。二分查找的基本思想:首先讲给定key与表中间位置的元素比较，若相等，则查找成功；若不相等，则所需查找的元素之可能在中间元素的前半部分或者后半部分，然后缩小查找范围，继续查找。

**分块查找**: 结合了顺序查找和分块查找的优点。将查找表分为若干子块，快内元素可以无序，块之间是有序的，即第一个块的最大元素小于第二个块中的所有元素，以此类推。再建立一个索引表，索引表中的每个元素含有各块的最大关键字和各块中的第一个元素的地址，索引表按关键字有序排列。查找时，首先在索引表中确定待查记录所在的块，可顺序查找或二分查找；第二步在块内顺序查找。

### 14. 十大排序算法的基本思想是什么？时间复杂度？是否稳定？给一个例子，问冒泡和快速排序在最坏的情况下比较几次？为什么快排叫快排（排序必考）★★★★★★

**十大排序** https://www.cnblogs.com/onepixel/articles/7674659.html

**为什么快排叫快排**:

https://blog.csdn.net/weixin_41445507/article/details/90255906

https://blog.csdn.net/linfeng24/article/details/38429055

快速排序快的主要原因使用了二分的思想，大大减少了比较和交换的次数，因为按基准数切分的两半数组，在一个数组里面的数据是绝对不会和第二个数组里面的数字产生比较的机会的，所以大幅度降低了做无用功的机会。

**为什么在平均情况下快速排序比堆排序要优秀？**

简单来说，就是局部性原理。

在堆排中，每一个操作都是不利于程序的局部性原理的，每次元素间的比较. 数的调整等，都不是相邻或者尽可能附近的元素间的比较(堆调整每次都从堆底拿元素到堆顶然后向下进行调整），那么这就需要不断地在磁盘和内存间换入换出数据。

反观快排，利用分而治之的方法，元素间的比较都在某个段内，局部性相当好哇。

**快速排序为什么比归并快**

快速排序比归并快的原因是因为快速排序中没有大批量的数据复制。而归并排序则每完成一趟就要复制整个排序部分的数组，所以时间的花销大

**为什么要稳定排序**

假定在待排序的记录序列中，存在多个具有相同的关键字的记录，若经过排序，这些记录的相对次序保持不变

稳定排序可以让第一个关键字排序的结果服务于第二个关键字排序中数值相等的那些数，例如成绩一样的按上次成绩靠前的排在前面。

### 15. 最小生成树和最短路径用什么算法来实现？（Dijkstra. Floyd. Prim. Kruskal）算法的基本思想是什么？算法的时间复杂度？如何进行优化？★★★★★★★

最小生成树:  Prim， Kruskal

最短路:Dijkstra，Floyd，单源负权边时是SPFA算法

Prim，Kruskal，Dijkstra是贪心。

floyd是动态规划，也就是枚举中间点，i - j 的距离可以被优化成经过中间点k, i - k - j

Dijkstra是O($n^2$)

floyd为O($n^3$)

Prim是O($n^2$)

kruskal是O($ElogE$)

kruskal：假设连通网N = ( V , E ) N=(V,E)N=(V,E)，将N NN中的边按权值从小到大的顺序排列。
①初始状态为只有n nn个顶点而无边的非连通图T = ( V , { } ) T=(V,\{\})T=(V,{})，图中每个顶点自成一个连通分量。
②在E EE中选择权值最小的边，若该边依附的顶点落在T TT中不同的连通分量上（即不形成回路），则将此边将入到T TT中，否则舍去此边而选择下一条权值最小的边。
③重复②，直到T TT中所有的顶点都在同一连通分量上为止。

Prim：prim算法基于贪心，我们每次总是选出一个离生成树距离最小的点去加入生成树，最后实现最小生成树

Dijkstra：对于Dijkstra算法，我们假设初始集合（也就是初始条件）不存在任何顶点的，即所有顶点之间是不存在任何路径的，即我们认为所有顶点之间的距离都是无穷大。那么开始加入新的条件，因为我们已知源点距源点距离最小，所以加入进去，并加入它的边，在该条件下，更新该源点到其余顶点的最短距离，选出没有加入到已知集合的距源点距离最小的点，此点最短距离也被确定了（因为其他路径都比这条路径大，无法通过其他路径间接到达这个顶点使得路径更小），然后加入该点与其余还未加入已知条件顶点的边，并以该点迭代刷新最短距离。再重复以上操作，直至所有顶点都加入已知条件集合。


### 16. 邻接表和邻接矩阵（如何存储大数据）★

图的存储方式有两种，邻接矩阵和邻接表。

**邻接矩阵**:用二维矩阵来存储图的节点和边。如果矩阵的第 i 行第 j 列为1，说明顶点 i, j 之间有边；如果为无穷，说明 i, j 之间不存在边，这个二维数组被称为邻接矩阵。**邻接矩阵**适用于**顶点数目较少**的情况

**邻接表**:用邻接表来存储图的节点和边。将所有的顶点作为链表头节点，放在一个列表中，然后每个链表存放对应顶点的所有出边。**在顶点数目比较大**的情况下使用**邻接表**来存储图

### 17. 介绍一下深度优先搜索和广度优先搜索是如何实现的？★★★

深度优先搜索算法和广度优先搜索算法都是基于**图**这种数据结构的。

**广度优先搜索**类似二叉树的层次遍历，基本思想是，首先访问起始顶点v，接着由v出发，依次访问v的各个未访问过的邻接顶点w1, w2 ...，然后依次访问w1, w2...的所有未被访问过的邻接顶点，重复上述过程，直到图中所有顶点都被访问过为止。

**深度优先搜索**类似于二叉树的先序遍历，基本思想是，首先访问起始顶点v，然后由v出发，访问与v邻接且未被访问的顶点w1，再访问与w1邻接且未被访问的顶点w2，重复上述过程，当不能再继续向下访问时，依次退回到最近被访问的顶点，若它还有邻接顶点未被访问过，则从该点开始继续上述搜索过程，直到图中所有顶点都被访问过为止。

### 18. 介绍一下字符串匹配算法:朴素的匹配算法和KMP算法。（如何实现要会用语言描述）★★★

**朴素匹配算法**:遍历主串的每一个字符，分别和子串的第一个字符比较，若不相等，则继续遍历；若相等，则依次比较剩余字符，直至子串的每个字符依次和主串的连续的字符序列相等。最坏时间复杂度为O(mn)

**KMP算法**:KMP算法是一种高效的字符串匹配算法。核心是找出next数组，又叫前缀表。

首先定义文本字符串 T 和需要在文本中查找的字符串 P

next数组表示的是，字符串 P 的最大公共前后缀中的公共前缀的最后一个字符的下标。知道这个下标，就可以知道当字符串 P 匹配出错时，P 的指针如何回退。

当进行字符串匹配时，如果字符串 T 和 P 的当前字符不匹配，通过next数组，我们可以知道 P 字符串应该回退到什么位置，而T的指针不用回退。这样只需要遍历一遍字符串T，就可以知道是否存在目标字符串，时间复杂度为O(n + m)

### 19. 哈夫曼树的定义，怎么求，应用？★

**定义**:在含有n个带权叶节点的二叉树中，带权路径长度（WPL）最小的二叉树称为哈夫曼树（从根到任意节点的路径长度与该节点上权值的乘积，称为该节点的带权路径长度）.

**怎么求**:每次从节点中选择根节点权重最小的两个子树组合成新的树，树的根节点为左右子树权值之和，重复选择，知道只剩下一棵树为止。

**应用**:利用哈夫曼树求前缀编码（在一个编码系统中，任意一个编码不能成为其它任意编码的前缀，则称该编码系统中的编码是前缀编码），可用于文件压缩.

### 20. 介绍下动态规划，贪心算法

动态规划:将一个问题拆成几个字问题，然后分别求解这些子问题，即可推断出大问题的解。包括自顶向下和自底向上两种。比如斐波那契数列

贪心算法:只考虑当前最优策略，比如

动态规划考虑与当前状态相关的所有状态，而贪心算法只考虑当前状态相关的最优状态

### 判断完全二叉树

https://cloud.tencent.com/developer/article/1339604

层次遍历，如果遍历到空节点，并且队列非空，说明树不是完全二叉树

## 计算机网络

计网面试 https://www.cnblogs.com/zyf-zhaoyafei/p/4716297.html

### 1. OSI和TCP/IP模型各个层之间的协议和功能★★★★★★✅

![image-20220603233659580](/Users/userli/Desktop/imgs_typora/image-20220603233659580.png)

**物理层**:在物理介质上传输**比特**流

**数据链路层**:定义了如何格式化数据，从而对其进行传输。它可以将来自网络层的IP数据报组装成帧，还可以进行差错控制，流量控制，以保证数据的可靠传输。

**网络层**:传输单位是IP数据报。主要功能有:

- 异构网络互联:将不同的网络通过中间设备连接
- 路由选择，分组转发
- 拥塞控制

**传输层**:传输单位是报文段或用户数据报，负责将数据可靠地传送到相应的端口。将上层数据分段并提供端到端的传输，还可以进行端到端的差错控制和流量控制。

**会话层**:负责创建、管理和终止表示层实体之间的通信会话

**表示层**:处理在两个通信系统中交换信息的方式。可以对数据进行压缩，加密和解密，确保一个系统的应用层发送的数据能被另一个系统的应用层识别

**应用层**:为应用程序提供访问网络服务的接口，比如文件传输，电子邮件等。

> https://www.nowcoder.com/discuss/566031?type=all&order=recall&pos=&page=1&ncTraceId=&channel=-1&source_id=search_all_nctrack&gio_id=B1B9CC1DF98AD17A15870A7FB81A1445-1652440775002
> 
> 物理层，数据链路层，网络层，传输层，会话层，表示层和应用层
> 
> 物理层:建立、维护、断开物理连接
> 
> 数据链路层:该层的作用包括了物理地址寻址，数据的成帧，流量控制，数据的检错，重发等。该层控制网络层与物理层之间的通信，解决的是所传输数据的准确性的问题。为了保证传输，从网络层接收到的数据被分制成特定的可被物理层传输的帧。帧是用来移动数据的结构包，它不仅包括原始数据，还包括发送方和接收方的物理地址以及纠错和控制的信息。其中的地址确定了帧将发送的位置，纠错和控制信息则保证帧的准确到达。如果传送数据的过程中，接收点检测到数据有错误，就通知发送方重新发送这一帧。
> 
> 网络层:主要功能是讲网络地址翻译成对应的物理地址，并决定如何将数据从发送方路由到接受他，他解决的是寻址和优化传输路径的问题。
> 网络层通过综合考虑发送优先权，网络拥塞程度，服务质量以及可选择路由的花费决定从一个网络中节点A到另一个网络中节点B的最佳路径。在网络中，“路由（router）”基于编址方案，使用模式以及可达性来指引数据的发送，网络层负责在原机器和目的机器之间建立他们所使用的路由
> 网关:网间连接器,协议转换器,网关在网络层上实现网络互连,对接收到的信心重新打包,以适应目的系统的需求
> 解决阻塞的办法:数据分组,编号传输出去;然后接收到数据后排序重组解码;选择最优路径;丢包也是发生在网络层.
> 
> 传输层:按照网络能处理的最大尺寸将教程的数据包进行强制分割，发送方节点的传输层将数据分割成交小的数据片，同时对每一个数据片安排一序列号，以便数据到达接收方的传输层时能以正确 的顺序重组，该过程称为排序。

> 数据链路层
> 
> **功能**:数据链路层在物理层提供服务的基础上**向网络层提供服务**，其最基本的服务是将来自网络层的数据可靠的传输到相邻节点的目标机网络层。其主要作用是**加强物理层传输原始比特流的功能**，将物理层提供的可能出错的物理连接改造成为**逻辑上无差错的数据链路**，使之对网络层表现为一条无差错的链路。
> 
> **区别**:
> 
> 1. 链路层流量控制是点对点的，接收方收到不回复确认
> 
> 2. 传输层是端到端的，接收端给发送端一个窗口大小
> 
> **数据链路层差错控制**:
> 
> 1. 检错编码:奇偶校验码，循环冗余码
> 2. 纠错编码:海明码
> 
> **数据链路层流量控制**
> 
> 1. 停止-等待协议:每发完一个帧就停止发送，等待对方的确认，在收到确认后再发送下一个帧（传输效率低）
> 
> 2. 滑动窗口协议:发送方维持一个发送窗口（一组连续的允许发送的帧的序号），接收方维持一个接收窗口（一组连续的允许接受的帧的序号）。接受方收到数据帧后，将窗口向前移动一个位置，并且返回确认帧。发送方收到确认帧后，发送窗口就向前滑动一个帧的位置。
>    
>    - 后退N帧协议（GBN）:发送窗口 > 1，接受窗口 = 1
>      
>      发送方:对n号帧的确认采用**累积确认**的方式，表明接收方已经收到n帧和它之前的全部帧；如果出现超时，发送方重传所有已经发送但未被确认的帧。
>      
>      接收方:如果正确并且按序收到n号帧，为n帧发送一个ACK，并且将改帧中的数据部分交付给上层；**其余情况丢掉帧**，并且为最近按序接受的帧重新发送ACK。
>    
>    - 选择重传协议（SR）:发送窗口 > 1，接受窗口 > 1
>      
>      发送方:如果收到ACK，若该帧在窗口内，则对应的帧标记为已接受，若该帧为窗口的下界，则窗口向前移动；
>      
>      接收方:接受全部窗口内的帧而不管是否按序。失序帧将被缓存，并且返回一个该帧的确认帧，直到所有帧都被接受，然后才可以将这一批帧交付给上层，然后向前推进滑动窗口。
>    
>    滑动窗口可以解决流量控制（窗口），可靠传输（[ARQ协议](###ARQ 协议)）
> 
> #### **介质访问控制**
> 
> ##### 信道划分介质访问控制:
> 
> 1. 频分多路复用:为用户分配不同的频率带宽
> 2. 时分多路复用:将时间划分为等长的时分复用帧，用户轮流占用信道
> 3. 波分多路复用:光的频分多路复用
> 4. 码分多路复用:
> 
> **随机访问介质访问控制**
> 
> 1. ALOHA协议:（不听就说）
>    - 纯ALOHA:不监听信道，不按时间槽发送，随机重发。
>    - 时隙ALOHA:把时间分成若干相同的时间片，若发生冲突，则必须等到下一个时间片开始时再发送
> 2. [CSMA协议(先听再说), CSMA/CD协议(先听再说，边听边说)](###6. 简述一下CSMA/CD协议★★★★)

### 2. 计算机网络为什么要分层？优点？ ★★★★★★✅

1. **每层只实现一种相对独立的功能，降低复杂度, **易于实现和维护**。**
   
   > 计算机网络的需求很繁杂，我们需要实现进程与进程的通信. 主机与主机的通信. 设备与设备的通信，这些都要在不同的层面上完成。分层结构使实现和调试一个庞大而又复杂的系统变得易于处理，因为整个的系统已被分解为若干个相对独立的子系统。**

2. **分层可以保证下层对上层的独立性，上层单向使用下层提供的服务。**某一层并不需要知道它的下一层是如何实现的，而仅仅需要知道下一层通过层间的接口所提供的服务。

3. **各层功能的定义独立于具体的实现方法，可以采用最合适的技术来实现**

4. **能促进标准化工作。**因为每一层的功能及其所提供的服务都已有了精确的说明。

### 3. 半双工. 全双工通信？★★

**单工**:主机只能从一边到另一边的通信，一边是发送端，另一边是接收端，不可逆，通道是单向的。比如广播站。

**半双工**:可以双向通信，但是同一时间，只能一边向另一边通信。即同一时间，只能单向通信；通过不同时间，来实现双向通信。发送端可以变接收端，接收端可以变发送端。比如对讲机（可以实现不同时间以双向通话，但同一时间，只能一个人在说话）

**全双工**:任意时刻，都能够两边同时通信，可以同时接收或者发送数据。比如电话。

### 5. 数据发送过程

1. 应用层要发送一个文件，报文
2. 传输层将报文分段
3. 网络层对报文段封装，给报文段加上源主机IP地址和目的主机IP地址，网络层将报文段封装成IP数据报，也叫分组。分组通常指数据报分片之后的结果。为什么要分片， 可能要传输的链路的链路层协议要求的MTU最大传输单元
4. 链路层封装，加上MAC地址，源MAC地址和目的MAC地址，最后再加上一个帧检验序列，构成数据帧。
5. 物理层对数据帧进行传输。

网络层封装IP地址，链路层封装MAC地址，物理层形成比特流的形式。

### 6. 简述一下CSMA/CD协议★★★★

**CSMA协议(载波侦听多路访问)（Carrier Sense Multiple Access)**

**非持续CSMA**:

1. 如果一个主机要发送消息，先监听信道，如信道空闲则直接传输，不必等待 
2. 信道忙则**等待一个随机时间再监听**

优点:等待一个随机时间可以减少再次碰撞冲突的可能性 
缺点:如果在这个随机时间内介质上没有数据传送，则会发生浪费 

**1-坚持CSMA**: 

1. 如果一个主机要发送消息，先监听信道，如果信道空闲则直接传输，不必等待 
2. 信道忙则**持续监听，直到空闲马上传输** 
3. 如果发生冲突，等待一个随机长的时间再重复上述步骤

优点:持续式的延迟时间要少于非持续式 
缺点:如果两个以上的站等待发送，一旦介质空闲就一定会发生冲突 

**p-坚持CSMA**: 

1. 如果一个主机要发送消息，先监听信道
2. 如果信道空闲，那么以p的概率直接发送，以(1–p)的概率延迟一个时间单元发送 
3. 如介质忙，持续侦听，直到信道空闲

优点:既能像非坚持算法那样减少冲突，又能像1-坚持算法那样减少了传输媒体的空闲时间 
缺点:信道发生冲突时仍坚持把数据帧发送完，造成了浪费

**CSMA/CD协议（Collision Detection:碰撞检测）** 

协议是CSMA 协议的改进方案。

**CS**:载波监听:每一个站点**在发送数据之前**和**发送数据时**都会检查信道是否有其他计算机在发送数据

**MA**:多路访问:很多计算机以多点接入的方式连接在一根总线上（总线型网络）

**CD**:碰撞检测**:就是边发送边侦听**，即适配器边发送数据边检测信道上信号电压的变化情况，以便判断自己在发送数据时其他站点是否也在发送数据。（CSMA/CD协议为半双工通信）

工作流程可简单概括为“先听后发，边听边发，冲突停发，随机重发”。 

1) 适配器从其父结点获得一个网络层数据报，准备一个以太网帧，并把该帧放到适配器缓冲区中，准备发送。 

2) 如果适配器侦听到信道空闲，那么它开始传输该帧。如果适配器侦听到信道忙，那么它将等待直至侦听到没有信号，然后开始传输该帧。
3. 在传输过程中，适配器持续监测信道。若一直未检测到碰撞，则顺利发送该帧，若监测到碰撞，则终止数据发送，并且发送一个拥塞信号，让所有用户知道。
4) 在中止（即传输拥塞信号）后，适配器采用**截断二进制指数退避算法**等待一段随机时间后再重复上述步骤。 

### 7. TCP和UDP的异同点★★★★★★

- 用户数据报协议 UDP（User Datagram Protocol）是无连接的，尽最大可能交付，不可靠，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），支持一对一、一对多、多对一和多对多的交互通信。
- 传输控制协议 TCP（Transmission Control Protocol）是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条 TCP 连接只能是点对点的（一对一）。

**相同点**:

TCP和UDP都是传输层协议，都能都是保护网络层的传输，双方的通信都需要开放端口。

**不同点**:

![image-20220630180648932](/Users/userli/Desktop/imgs_typora/image-20220630180648932.png)

<table>
  <thead>
    <tr>
      <th>TCP</th>
      <th>UDP</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>*TCP的传输是可靠传输。</td>
      <td>*UDP的传输是不可靠传输。</td>
    </tr>
    <tr>
      <td>*TCP是基于连接的协议，在正式收发数据前，必须通过三次握手机制和对方建立可靠的连接。确保双方准备好，在传输数据包期间，TCP会根据链路中数据流量的大小来调节传送的速率，传输时如果发现有丢包，会有严格的重传机制，故而传输速度很慢。</td>
      <td>*UDP是面向非连接的协议，它不与对方建立连接，而是直接把数据包发送出去。UDP在传输数据报前不用在客户和服务器之间建立一个连接，且没有超时重发等机制，故而传输速度很快。</td>
    </tr>
    <tr>
      <td>TCP是一种可靠的通信服务，负载相对而言比较大，TCP采用套接字（socket）或者端口（port）来建立通信。</td>
      <td>UDP是一种不可靠的网络服务，负载比较小。</td>
    </tr>
    <tr>
      <td>TCP和UDP结构不同，TCP包括序号. 确认信号. 数据偏移. 控制标志（通常说的URG. ACK. PSH. RST. SYN. FIN）. 窗口. 校验和. 紧急指针. 选项等信息。</td>
      <td>UDP包含长度和校验和信息。</td>
    </tr>
    <tr>
      <td>TCP提供超时重发，丢弃重复数据，检验数据，流量控制等功能，保证数据能从一端传到另一端。</td>
      <td>UDP不提供可靠性，它只是把应用程序传给IP层的数据报发送出去，但是并不能保证它们能到达目的地。</td>
    </tr>
    <tr>
      <td>TCP支持全双工和并发的TCP连接，提供确认. 重传与拥塞控制。</td>
      <td>UDP适用于那些系统对性能的要求高于数据完整性的要求，需要“简短快捷”的数据交换. 需要多播和广播的应用环境。</td>
    </tr>
  </tbody
</table>

### 8. TCP的三次握手四次挥手过程？为什么会采用三次握手，若采用二次握手可以吗？★★★★★

**三次握手**

进行三次握手的主要作用就是为了确认双方的接收能力和发送能力是否正常、指定自己的初始化序列号为后面的可靠性传送做准备。

<img src="/Users/userli/Desktop/imgs_typora/image-20220603235323552.png" alt="image-20220603235323552" style="zoom: 33%;" />

1. 客户端向服务器发送一个连接请求报文段。这个特殊的报文段中不含应用层数据，其首部中的SYN标识位被置为1。随后，客户端会随机选择一个起始序号seq = x（连接请求报文不携带数据，但要消耗一个序号）
2. 服务器收到连接请求报文段后，如果同意建立连接，就向客户端发回确认，并且为该TCP分配TCP缓存和变量。在确认报文段中，SYN和ACK都被置为1，确认号字段的值ack = x + 1，并且服务器随机产生起始序号seq = y（确认报文不携带数据，但也要消耗一个序号）。确认报文段同样不包含应用层数据
3. 当客户端收到确认报文段后，还要向服务器给出确认，并且也要给改连接分配缓存和变量。这个报文段的ACK被置为1，序号字段为x + 1，确认号字段ack = y + 1。该报文**可以携带数据**，若不携带则不消耗序号。

TCP提供全双工通信，因此通信双方的应用进程在任何时候都能发送数据。

**四次挥手**

<img src="/Users/userli/Desktop/imgs_typora/image-20220603235443098.png" alt="image-20220603235443098" style="zoom: 33%;" />

1. 客户端打算关闭连接时，向服务器发送一个连接释放报文段，并停止发送数据，主动关闭TCP连接。该报文段的FIN置为1，seq = u，它等于前面已经传送过的数据的最后一个字节的序号 + 1. 由于TCP是全双工的，发送FIN报文是，发送端不能再发送数据，但接收端仍可以发送数据
2. 服务器收到连接释放报文段后发出确认ACK，确认号ack = u + 1，这个报文段的序号为v，它等于前面已经传送过的数据的最后一个字节的序号 + 1。此时，从客户端到服务器的连接被释放，但从服务器到客户端的连接仍未被关闭。
3. 若服务器没有要发送的数据，则向客户端发送FIN = 1的报文段释放连接
4. 客户端收到连接释放报文段后，需要发出确认。此时TCP连接还未释放，必须经过时间等待计时器设置的时间2MSL后，客户端才进入连接关闭状态。

> [为什么要2MSL](https://blog.csdn.net/hyg0811/article/details/102366854)
> 
> https://blog.csdn.net/overstack/article/details/8833894
> 
> 当TCP执行一个主动关闭，并发回最后一个ACK，该连接必须在TIME_WAIT状态停留的时间为2倍的MSL（报文段最大生存时间）。这样可让TCP再次发送最后的ACK以防这个ACK丢失（另一端超时并重发最后的FIN）。
> 
> 等待2MSL时间主要目的是怕最后一个ACK包对方没收到，那么对方在超时后将重发第三次挥手的FIN包，主动关闭连接的一端，接到重发的FIN包后可以再发一个ACK应答包。

### 9. 介绍下TCP和UDP协议的特点. 头部结构★★★★★

**UDP的特点**:

1. 无需建立连接，因此UDP不会引入建立连接的时延。
2. 无连接状态。TCP需要在端系统中维护连接状态，包括接收和发送缓存，拥塞控制参数，序号与确认号等参数。而UDP无需维护连接状态。
3. 分组首部开销小，TCP有20B的首部开销，而UDP只有8B。
4. 应用层可以更好的控制要发送的数据和发送时间。UDP没有拥塞控制，因此网络中的拥塞不会影响主机的发送效率。

**UDP头部结构**:

<img src="/Users/userli/Desktop/imgs_typora/image-20220616222359183.png" alt="image-20220616222359183" style="zoom:50%;" />

**TCP特点**:

TCP在不可靠的IP层之上实现了可靠的数据传输协议。特点如下

1. TCP是面向连接的传输层协议，是面向字节流的协议。

2. 每条TCP连接只能有两个端点。

3. TCP提供可靠的交付服务，保证传送的数据无差错，不丢失，不重复且有序

4. TCP提供全双工通信，允许通信双方的应用进程在任何时候都能发送数据，为此TCP连接的两端都设有发送缓存和接收缓存，用来临时存放双向通信的数据。
   
   发送缓存存放:将要发送的数据；TCP已发送但尚未收到确认的数据；
   
   接收缓存存放:按序到达但尚未被读取的数据；不按序到达的数据。

**TCP头部结构**

<img src="/Users/userli/Desktop/imgs_typora/image-20220616222421608.png" alt="image-20220616222421608" style="zoom:50%;" />

<img src="/Users/userli/Desktop/imgs_typora/image-20220616222453317.png" alt="image-20220616222453317" style="zoom:50%;" />

<img src="/Users/userli/Desktop/imgs_typora/image-20220616222513973.png" alt="image-20220616222513973" style="zoom:50%;" />

### 10. 简述下TCP建立连接的过程,TCP如何保证可靠传输？★★★★★★

[握手过程](###8. TCP的三次握手四次挥手过程？为什么会采用三次握手，若采用二次握手可以吗？★★★★★)

**如何保证可靠传输**

1. **校验和**: TCP 将保持它的数据段的检验和，目的是检测数据在传输过程中的变化。如果收到数据段的校验和有差错，TCP 将丢弃这个报文段。

2. **序列号**:TCP传输时为每个字节的数据都进行了编号。服务器根据序列号将接收到的数据进行排序，并且去掉重复序列号的数据。

3. **确认应答**:TCP传输过程中，每次接收方收到数据后，都会对传输方进行确认应答，也就是发送ACK报文。这个ACK报文中带有对应的确认序列号，告诉发送方，接收到了哪些数据，下次的数据从哪里发。

4. **超时重传**: 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认ACK，将重发这个报文段。
   
   > 发送方没有接受到响应的ACK报文原因可能有两点:
   > 
   > 1. 数据在传输过程中由于网络原因等直接全体丢包，接收方根本没有接收到。
   > 
   > 2. 接收方接收到了响应的数据，但是发送的ACK报文响应却由于网络原因丢包了。
   > 
   > TCP引入超时重传机制。简单理解就是发送方在发送完数据后等待一个时间，时间到达没有接收到ACK报文，那么对刚才发送的数据进行重新发送。如果是刚才第一个原因，接收方收到二次重发的数据后，便进行ACK应答。如果是第二个原因，接收方发现接收的数据已存在（判断存在的根据就是序列号，所以上面说序列号还有去除重复数据的作用），那么直接丢弃，仍旧发送ACK应答。
   
   <img src="/Users/userli/Desktop/imgs_typora/image-20220617001620913.png" alt="image-20220617001620913" style="zoom:40%;" />

5. **流量控制**: TCP 连接的每一方都有固定大小的缓冲空间，TCP 的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，可以通过设置确认报文段首部的窗口字段来调整接收窗口的大小，从而提示发送方降低发送的速率，防止包丢失。// TCP 使用的流量控制协议是可变大小的滑动窗口协议。 （TCP 利用滑动窗口实现流量控制）

> #### **滑动窗口和流量控制**
> 
> **TCP 利用滑动窗口实现流量控制。流量控制是为了控制发送方发送速率，保证接收方来得及接收。** 接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。

### 11. 在TCP拥塞控制中，什么是慢开始. 拥塞避免. 快重传和快恢复算法？★★★★

**拥塞控制**就是为了防止过多的数据注入到网络中，这样就可以使网络中的路由器或链路不致于过载。拥塞控制和流量控制都是通过控制发送方的发送速率来进行控制。拥塞控制是一个全局性的过程，涉及到所有的主机，路由器，以及与降低网络传输性能有关的所有因素。相反，流量控制往往是点对点通信量的控制，即接收端到发送端，他要做到的就是抑制发送端发送数据的速率，以便使接收端来得及接收。

为了进行拥塞控制，TCP 发送方要维持一个 **拥塞窗口(cwnd)** 的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个。

TCP 的拥塞控制采用了四种算法，即 **慢开始**，**拥塞避免**， **快重传**和**快恢复**。

* **慢开始**: 慢开始算法的思路是当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么可能会引起网络阻塞，因为现在还不知道网络的实际情况。经验表明，较好的方法是先探测一下，即由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值。拥塞窗口 初始值为 1，每经过一个传输轮次，拥塞窗口加倍。

* **拥塞避免**: 在慢开始算法将拥塞窗口增大到一个阈值时，改用拥塞避免算法。拥塞避免算法的思路是让拥塞窗口缓慢增大，即每经过一个往返时间 RTT 就把发送端的拥塞窗口加 1. 一旦造成网络拥塞，发生超时重传时，阈值会为原来的一半（这里的原来指的是发生网络拥塞时拥塞窗口的大小），同时拥塞窗口重置为 1。

* **快重传**:
  在 TCP/IP 中，快速重传和恢复（fast retransmit and recovery，FRR）是一种拥塞控制算法，它能快速恢复丢失的数据包。没有 快速重传和恢复，如果数据包丢失了，TCP 将会使用定时器来要求传输暂停。在暂停的这段时间内，没有新的或复制的数据包被发送。有了 快速重传和恢复，如果服务器接收到一个不按顺序的数据段，它会立即给客户端发送一个重复确认。如果客户端接收到三个重复ACK报文，它会立即重传丢失的数据段，就不会因为重传时要求的暂停被耽误。 当有单独的数据包丢失时，快速重传和恢复能最有效地工作。当有多个数据信息包在某一段很短的时间内丢失时，它则不能很有效地工作。

* **快恢复**
  
  客户端收到连续三个冗余ACK时，将慢开始阈值设置为原来的一半，将拥塞窗口的值设置为减半后的慢开始阈值，然后开始执行拥塞避免算法。由于跳过了拥塞窗口从1开始的慢开始过程，因此被称为快恢复。

### 12. TCP的快速重传机制★★★★

* **快重传**:
  在 TCP/IP 中，快速重传和恢复（fast retransmit and recovery，FRR）是一种拥塞控制算法，它能快速恢复丢失的数据包。没有 快速重传和恢复，如果数据包丢失了，TCP 将会使用定时器来要求传输暂停。在暂停的这段时间内，没有新的或复制的数据包被发送。有了 快速重传和恢复，如果服务器接收到一个不按顺序的数据段，它会立即给客户端发送一个重复确认。如果客户端接收到三个重复ACK报文，它会立即重传丢失的数据段，就不会因为重传时要求的暂停被耽误。 　当有单独的数据包丢失时，快速重传和恢复能最有效地工作。当有多个数据信息包在某一段很短的时间内丢失时，它则不能很有效地工作。

* **快恢复**
  
  客户端收到连续三个冗余ACK时，将慢开始阈值设置为原来的一半，将拥塞窗口的值设置为减半后的慢开始阈值，然后开始执行拥塞避免算法。由于跳过了拥塞窗口从1开始的慢开始过程，因此被称为快恢复。

### 13. 流量控制和拥塞是什么关系? ★★★★

**拥塞控制**就是为了防止过多的数据注入到网络中，这样就可以使网络中的路由器或链路不致过载，常用的方法有慢开始，拥塞避免，快重传和快恢复。拥塞控制和流量控制都是通过控制发送方的发送速率来进行控制。拥塞控制是一个全局性的过程，涉及到所有的主机，路由器，以及与降低网络传输性能有关的所有因素。相反，**流量控制**往往是点对点通信量的控制，即接收端到发送端，他要做到的就是抑制发送端发送数据的速率，以便使接收端来得及接收。

### 14. 两个服务器之间网络已经联通，却收不到彼此的UDP报文原因★★★★

UDP协议没有流量控制、拥塞控制，可能因为网络拥塞的原因

### 15. 地址解析协议ARP★★

无论网络层使用什么协议，在实际网络的链路上传送数据帧时，最终必须使用硬件地址。ARP可以完成IP地址到MAC地址的映射。每台主机都有一个ARP高速缓存，用来存放本局域网上各主机和路由器的IP地址到MAC地址的映射表。

若发送方要把IP数据包发送到本网络下的另一台主机，需要用ARP协议找到目的主机的硬件地址；

若发送方要把IP数据包发送到另一个网络上的一台主机，需要用ARP找到本网络上的一个路由器的硬件地址，让这个路由器把分组转发给下一个网络，剩下的工作由下一个网络完成。

### 24. DHCP的作用？★★

动态主机配置协议（DHCP），**主机可以从服务器动态获取IP地址**。是一种基于UDP的应用层协议，客户端和服务器通过广播的方式进行交互。

1. 主机广播DHCP发现报文
2. DHCP服务器广播DHCP提供报文
3. 主机广播DHCP请求报文（这里的广播是为了让其他DHCP服务器收回刚才的地址）
4. DHCP服务器广播DHCP确认报文

### 16. 网关？网卡？网桥？

**网关**:

网关用于在传输层上实现网络互连。它实质上是**一个网络通向其他网络的IP地址**。在没有路由器的情况下，两个网络之间是不能进行通信的。而要实现这两个网络之间的通信，则必须通过网关。如果网络A中的主机发现数据包的目的主机不在本地网络中，就把数据包转发给它自己的网关，再由网关转发给网络B的网关，网络B的网关再转发给网络B的某个主机。网络B向网络A转发数据包的过程。

**网卡**:

网卡是链路层的网络组件，是局域网中连接计算机和传输介质的接口。可以将电信号重新转换文文字图像。网卡还有监控上传及下载流量，控制网速稳定的作用。

**网桥**:

工作在数据链路层，起到的作用是把多个局域网连接起来，组成更大的局域网。

### 17. 说下网络中的主机通信流程★★

主机A和主机B通信报文的转发过程

  1、主机A和主机B在同一个二层网络中，直接走二层交换

![img](https://images2017.cnblogs.com/blog/1195609/201712/1195609-20171228200451741-644917001.png)

主机A查看自己的ARP缓存，检查是否有主机B的IP到MAC的映射，如果有映射，构造报文，目的IP为主机B的IP，源IP为主机A的IP，目的MAC为主机B的MAC，源MAC为主机A的MAC，将报文发送给交换机C，交换机C进行MAC地址表学习，将主机A的MAC和报文入端口号记录下来，然后交换机C查看自己的MAC转发表，检查是否有主机B的MAC到端口的映射，如果有映射，获取对应的端口，将报文从此端口转发出去，报文到达主机B。如果交换机C没有主机B的MAC转发表映射，采用洪泛的形式广播报文，主机B收到报文后向主机A回复，交换机C进行MAC表学习，将主机B的MAC和报文入端口号记录下来。

如果主机A没有主机B的ARP映射，主机A需要发送ARP请求，以获取主机B的MAC，将报文发往交换机C，交换机C采用洪泛的形式广播报文，主机B收到广播报文后，在自己的ARP缓存表中写入主机A的IP到MAC的映射，将自己的MAC封装到ARP回复报文中，单播给主机A，主机A获取到主机B的MAC后，在自己的ARP缓存表中写入主机B的IP到MAC的映射，构造报文发送给主机B，过程同上。

主机B向主机A回复报文的过程类似。

  2、主机A和主机B不在同一个网络中，走三层路由

![img](https://images2017.cnblogs.com/blog/1195609/201712/1195609-20171228200451913-183257035.png)

主机A查看自己的ARP缓存表，检查是否有路由器E的IP到MAC的映射，如果有映射，获取路由器E的MAC，构造报文，目的IP为主机B的IP，源IP为主机A的IP，目的MAC为路由器E的MAC，源MAC为主机A的MAC，将报文通过交换机C发往路由器E，过程同上。 如果主机A没有路由器E的IP到MAC的映射，需要发送ARP请求，获取路由器E的MAC，过程同上。路由器E收到主机A的报文后，剥离报文的MAC帧头，查询路由表，发现目标主机B所在的网络是直连的，查看自己的ARP缓存表，如果有主机B的IP到MAC的映射关系，获取主机B的MAC，封装报文MAC帧头，目的MAC为主机B的MAC，源MAC为路由器E的MAC，将报文通过交换机D发往主机B，如果路由器E没有主机B的IP到MAC的映射关系，需要发送ARP请求，获取主机B的MAC，过程同上。

### 18. 一个主机将两个端口接到网络上是否会提升吞吐量？为什么？★★

这个要看你怎么用。如果两个端口均单独使用，那就要看每个端口的吞吐量是否平衡。如果某个端口吞吐量很小，那就没什么太大区别。

如果是端口做了捆绑，那就是两个物理端口可以当一个逻辑端口用。这个逻辑端口的最大吞吐量是物理端口的近似2倍。

### 19. 简述下DNS域名解析的过程。★★★★★

DNS实现**域名到IP地址的转换**

1. 当客户机提出查询请求时，首先在**本地计算机的缓存**中查找。如果在本地无法获得查询信息，则将查询请求发给本地DNS服务器。

2. 客户机将域名查询请求发送到**本地DNS服务器**（递归查询），当本地DNS服务器接到查询后，首先在该服务器管理的区域的记录中查找，如果找到该记录，则利用此记录进行解析；如果没有区域信息可以满足查询要求，服务器在本地的缓存中查找。

3. 如果本地服务器不能在本地找到客户机查询的信息，将客户机请求发送到**根域名DNS服务器**（迭代查询）。

4. 根域名服务器负责解析客户机请求的根域部分，它将包含下一级域名信息的DNS服务器地址返回给本地DNS服务器地址。

5. 本地DNS服务器利用根域名服务器解析的地址访问下一级DNS服务器，得到再下一级域名的DNS服务器地址。

6. 按照上述方法逐级访问查询目标，最后在有目标域名的DNS服务器上找到相应IP地址信息。

7. 客户机的本地DNS服务器将查询结果返回客户机，并且将查询结果保存到本地缓存。

8. 客户机利用从本地DNS服务器查询得到的IP访问目标主机，就完成了一个解析过程。

### 20. 点击网页一次HTTP请求过程？（在浏览器里输入一个网址，会发生什么）★★★

1. 浏览器分析url

2. 向DNS请求解析IP地址

3. [DNS域名解析的过程](###19. 简述下DNS域名解析的过程。★★★★★)

4. 浏览器与服务器建立TCP连接 [三次握手](###8. TCP的三次握手四次挥手过程？为什么会采用三次握手，若采用二次握手可以吗？★★★★★)

5. 浏览器发出[HTTP请求](https://developer.aliyun.com/article/415766)

6. 服务器通过HTTP响应将文件发送给浏览器

7. 释放TCP连接 [四次挥手](###8. TCP的三次握手四次挥手过程？为什么会采用三次握手，若采用二次握手可以吗？★★★★★)
   
   > HTTP分为持久连接和非持久连接

8. 浏览器显示页面

### 21. 机器的ip地址和mac地址，他们有什么区别，有什么用途？★★

1. IP地址是网络层逻辑地址，MAC地址是数据链路层物理地址
2. IP地址用于表示网络中某设备或节点的身份（网络位，主机位），可以区别不同的网段
3. MAC地址用于表示某设备或节点在本以太网链路中的物理地址
4. IP地址为32位，MAC地址为48位

### 22. HTTP状态码及其含义★★★★

https://blog.csdn.net/dgxin_605/article/details/109896967

### 23. HTTP和HTTPS的区别★★★★

HTTP 是应用层协议，它以 TCP（传输层）作为底层协议，默认端口为 80. 并且HTTP 是一个无状态（stateless）协议，也就是说服务器不维护任何有关客户端过去所发请求的消息。 

> ### HTTP 是不保存状态的协议, 如何保存用户状态?
> 
> HTTP 是一种不保存状态，即无状态（stateless）协议。也就是说 HTTP 协议自身不对请求和响应之间的通信状态进行保存。那么我们保存用户状态呢？Session 机制的存在就是为了解决这个问题，Session 的主要作用就是通过服务端记录用户的状态。典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了（一般情况下，服务器会在一定时间内保存这个 Session，过了时间限制，就会销毁这个 Session）。
> 
> 在服务端保存 Session 的方法很多，最常用的就是内存和数据库(比如是使用内存数据库 redis 保存)。既然 Session 存放在服务器端，那么我们如何实现 Session 跟踪呢？大部分情况下，我们都是通过在 Cookie 中附加一个 Session ID 来方式来跟踪。

HTTPS 协议，是 HTTP 的加强安全版本。HTTPS 是基于 HTTP 的，也是用 TCP 作为底层协议，并额外使用 SSL/TLS 协议用作加密和安全认证。默认端口号是 443.

> ### HTTPS为什么安全
> 
> > **非对称加密**:采用公钥和私钥。在通信时，私钥仅由解密者保存，公钥则可以被任何一个想与解密者通信的发送者知晓。
> > 
> > **对称加密**:通信双方共享唯一密钥，加解密算法已知，发送方利用密钥加密，解密方利用密钥解密，数据保密性依赖于密钥的保密性。
> 
> HTTPS 之所以能达到较高的安全性要求，就是结合了 SSL/TLS 和 TCP 协议，对通信数据进行加密。
> 
> SSL/TLS 的核心是非对称加密；但是非对称加密较为复杂，计算代价高，效率低，因此SSL/TLS使用对称加密对消息进行加密。因为对称加密的保密性完全依赖于密钥的保密性，因此在双方通信之前，需要商量一个用于对称加密的密钥。但密钥的交换不能直接在网络中传输，否则会被窃取，因此首先使用非对称加密 对 对称加密的密钥进行加密，保护该密钥不在网络信道中被窃听。这样，通信双方只需要进行一次非对称加密，来交换对称加密的密钥，就可以在之后的通信中，使用安全的对称加密进行通信，即保证了消息传输的安全性，又保证了消息传输的效率。
> 
> // 如果问到信安相关的，可以说一说数字签名
> 
> 在网络通信的过程中，攻击者可能对服务器的公钥进行伪造，从而导致发送者的信息泄漏。为了解决这个问题，需要证书颁发机构CA为服务器颁发证书，将证书存储在服务器上，并且附有CA的电子签名。
> 
> 当客户端向服务器发送 HTTPS 请求时，一定要先获取目标服务器的证书，并根据证书上的信息，检验证书的合法性。一旦客户端检测到证书非法，就会发生错误。客户端获取了服务器的证书后，由于证书的信任性是由第三方信赖机构认证的，而证书上又包含着服务器的公钥信息，客户端就可以放心的信任证书上的公钥就是目标服务器的公钥。
> 
> 数字签名，是 CA 在给服务器颁发证书时，使用散列+加密的组合技术，在证书上盖个章，以此来提供验伪的功能。具体行为如下:
> 
> > CA 知道服务器的公钥，对该公钥采用散列技术生成一个摘要。CA 使用 CA 私钥对该摘要进行加密，并附在证书下方，发送给服务器。
> > 
> > 现在服务器将该证书发送给客户端，客户端需要验证该证书的身份。客户端找到第三方机构 CA，获知 CA 的公钥，并用 CA 公钥对证书的签名进行解密，获得了 CA 生成的摘要。
> > 
> > 客户端对证书数据（也就是服务器的公钥）做相同的散列处理，得到摘要，并将该摘要与之前从签名中解码出的摘要做对比，如果相同，则身份验证成功；否则验证失败。

### 25. 能不能直接在应用层把数据交给网络层★★★

网络的分层保证了下层对上层的独立性，上层单向使用下层提供的服务；传输层为应用层提供了TCP可靠传输和UDP无连接服务，应用层只能使用传输层提供的接口，无法调用网络层的服务。网络层只能对来自传输层的数据包进行分组转发，无法处理来自应用层的数据。

### 26. 了解Socket吗？什么是socket？★★★★

socket =（主机IP地址，端口号）

Socket是一组编程接口（API）。介于应用层和传输层，向应用层提供统一的编程接口。应用层不必了解TCP/IP协议细节。直接通过对Socket接口函数的调用就可以完成数据在IP网络的传输。

### 27. 简述一下Cookie 和 Session的区别★★★

Cookie是存储在用户主机中的文本文件，记录某一段时间内某用户的访问记录。

1. **数据存放位置不同**:cookie数据存放在客户的浏览器上，session数据放在服务器上。

2. **安全程度不同**:cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗,考虑到安全应当使用session。

3. **性能使用程度不同**:session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能,考虑到减轻服务器性能方面，应当使用cookie。

4. **数据存储大小不同**:单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie，而session则存储与服务端，浏览器对其没有限制。

5. **会话机制不同**:
   
   session会话机制:session会话机制是一种服务器端机制，它使用类似于哈希表（可能还有哈希表）的结构来保存信息。
   
   cookies会话机制:cookie是服务器存储在本地计算机上的小块文本，并随每个请求发送到同一服务器。 Web服务器使用HTTP标头将cookie发送到客户端。在客户端终端，浏览器解析cookie并将其保存为本地文件，该文件自动将来自同一服务器的任何请求绑定到这些cookie。

### 路由器？

路由器是连接两个或多个网络的硬件设备，在网络间起网关的作用，是读取每一个数据包中的地址然后决定如何传送的专用智能性的网络设备。它能够理解不同的协议，例如某个局域网使用的以太网协议，因特网使用的TCP/IP协议。这样，路由器可以分析各种不同类型网络传来的数据包的目的地址，把非TCP/IP网络的地址转换成TCP/IP地址，或者反之；再根据选定的路由算法把各数据包按最佳路线传送到指定位置。所以路由器可以把非TCP/IP网络连接到因特网上。

## 操作系统

### 1. 操作系统的概念？特点？功能？✅

**概念**

操作系统可以控制和管理整个计算机系统的**硬件和软件资源**，并合理的组织调度计算机的资源分配，以及提供给用户和其他软件方便的接口和环境（向上为用户和其他软件提供服务）屏蔽了硬件层的复杂性，他是计算机系统中最基本的系统软件。

**特点**

操作系统四个基本特征:并发，共享，虚拟，异步；其中，并发和共享是OS最基本的特征。

1. **并发**:并发指一段时间内能同时运行多个程序，并行指同一时刻能运行多个指令。操作系统通过引入进程和线程，使得程序能够并发运行。

2. **共享**:共享是指系统中的资源可以被多个并发进程共同使用。它主要有两种共享方式:互斥共享和同时共享。多个应用并发执行的时候，宏观上要体现出它们在同时访问资源的情况，而微观上要实现它们的互斥访问。

3. **虚拟**
   
   虚拟技术把一个物理实体转换为多个逻辑实体。利用多道程序设计技术(程序的交替运行)，让每个用户都觉得有一个计算机专门为他服务。主要有两种虚拟技术:时间复用技术和空间复用技术。
   
   时间复用技术是指通过时间片轮转的方式让多个进程能在同一个处理器上并发执行，轮流占用处理器。
   
   空间复用技术值将物理内存抽象为地址空间，每个进程都有各自的地址空间。若没有足够的内存空间，则通过虚拟内存管理实现内存的分配。

4. **异步**:多道程序环境下，允许多个程序并发执行，但由于资源有限，进程执行不是一贯到底，而是走走停停，以不可预知的速度向前推进。

**功能**

操作系统是计算机系统资源的管理者，包括设备管理，文件管理，进程管理，进程通信，内存管理。操作系统还可以为用户与计算机硬件系统之间提供访问接口。

### 2. 进程/线程同步

#### 进程同步

**为什么要进程同步** 

多进程虽然提高了系统资源利用率和吞吐量，但是由于进程的异步性可能造成系统的混乱。进程同步的任务就是对多个相关进程在执行顺序上进行协调，使并发执行的多个进程之间可以有效的共享资源和相互合作，保证程序执行的可再现性。

**同步机制需要遵循的原则**:

空闲让进:当没有进程处于临界区的时候，应该许可其他进程进入临界区的申请

忙则等待:当前如果有进程处于临界区，如果有其他进程申请进入，则必须等待，保证对临界区的互斥访问

有限等待:对要求访问临界资源的进程，应保证进程能在有限时间进入临界区，以免陷入“饥饿”状态。

让权等待:当进程不能进入自己的临界区时，应立即释放处理机，以免进程陷入忙等

**进程同步的方式**:原子操作、信号量、管道。

#### 线程同步方式

1. 互斥(信号)量，每个时刻只有一个线程可以访问公共资源。只有拥有互斥对象的线程才能访问公共资源，互斥对象只有一个，一个时刻只能有一个线程持有，所以保证了公共资源不会被多个线程同时访问。

2. 信号量，允许多个线程同时访问公共资源。但是控制了访问资源的线程的最大个数。

3. 事件 in windows（条件变量 in linux）。通过通知的方式保持多线程的同步，还可以方便的实现多线程优先级的比较

4. 临界区。任意时刻只能有一个线程进入临界区，访问临界资源。

### 3. 进程. 线程的概念以及区别？进程间的通信方式？★★★★★★✅

https://blog.csdn.net/m0_38057941/article/details/120188564

**概念**

进程是运行的程序，是系统资源分配的基本单位。

线程是是CPU调度的基本单位。一个进程可以由多个线程组成

**进程与线程的区别**

1. 概念不同:进程是运行中的程序，是系统资源分配的基本单位。线程是是CPU调度和执行的基本单位，是进程的内部的一个执行序列·

2. 切换开销不同:进程间切换开销大，线程间切换开销小。**进程在执行过程中拥有独立的内存单元，多个线程共享进程的内存**。操作系统将资源分配给进程，同一进程的所有线程共享该进程的所有资源。
   
   > 同一进程中的多个线程共享代码段（代码和常量），数据段（全局变量和静态变量），扩展段（堆存储）。但是每个线程拥有自己的栈，用来存放所有局部变量和临时变量。

3. 通信方式不同:由于同一进程中的多个线程具有相同的地址空间，使得它们之间的同步和通信的实现比较容易。**而进程拥有独立的内存地址空间，进程间通信需要进程同步和互斥手段的辅助，以保证数据的一致性**。

**线程哪些资源共享？哪些资源不共享？**

- 共享:堆、全局变量、静态变量、文件等共用资源

- 独享:栈、寄存器

**进程间的通信方式** 

1. **共享存储(Shared memory)** :为了传输大量数据，在存储器中划出一块共享存储区，多个进程可以通过对共享存储区进行读写来实现通信。这种方式需要依靠某种同步操作，如互斥锁和信号量等。可以说这是最有用的进程间通信方式。
2. **消息传递(Message)** :进程间的数据交换以Message为单位，进程通过操作系统提供的“发送消息/接收消息”两个原语进行数据交换。消息传递可以分为以下两类
   - 直接通信:消息直接挂到接收进程的消息缓冲队列上
   - 间接通信:消息先发送到中间实体（信箱），接收进程从中获取消息。
3. **管道(Pipes)** :管道是指用于连接读写进程的一个共享文件，其实就是在内存中开辟的一个大小固定的缓冲区。
   - 管道只能采用半双工通信，某一时间段内只能实现单向传输，如果要实现双向同时通信，则需要设置两个管道
   - 各进程要互斥的访问管道
   - 数据以字符流的形式写入管道，当管道写满时，写进程的write系统调用将被阻塞，当读进程将数据全部取走后，读进程的read系统调用将被阻塞
   - 如果没写满，就不允许读，如果未读完，则不允许写
4. **套接字(Sockets)** : 此方法主要用于在**客户端和服务器之间通过网络**进行通信。套接字是支持 TCP/IP 的网络通信的基本操作单元，可以看做是不同主机之间的进程进行双向通信的端点，简单的说就是通信的两方的一种约定，用套接字中的相关函数来完成通信过程。

### 4. 进程有哪几种状态，状态之间的转换. 进程调度策略？★★★★✅

- **创建态(new)** :进程正在被创建，尚未到就绪状态。
- **就绪态(ready)** :进程已经获得了除CPU以外的所有所需资源，等待分配CPU资源，一旦得到CPU资源(处理器分配的时间片)即可运行。
- **运行态(running)** :进程已获得了CPU资源，正在运行。
- **阻塞态(waiting)** :又称为等待状态，进程**正在等待某一事件而暂停运行**如等待某资源为可用或等待 IO 操作完成。即使处理器空闲，该进程也不能运行。
- **结束态(terminated)** :进程正在从系统中消失。可能是进程正常结束或其他原因中断退出运行。

![image-20220601155008868](/Users/userli/Desktop/imgs_typora/image-20220601155008868.png)

[进程调度策略](###7. 介绍下几种常见的进程调度算法及其流程（FCFS，SJF，剩余短作业优先，优先级调度，轮转法，多级反馈队列等等）★★★★★★)

### 5. 什么是死锁？死锁产生的四个必要条件？如何预防死锁？★★★★★★✅

死锁:在并发环境下，各进程因资源竞争而造成的一种**互相等待对方资源，导致各进程都阻塞，无法向前推进**的现象。

饥饿:由于长期得不到想要的资源，导致进程无法向前推进的现象。

**死锁产生的必要条件**

- **互斥条件**:一段时间内资源只能被一个进程占有
- **不可剥夺条件**:进程所获的的资源在未用完之前，不能由其他进程强行夺走，只能主动释放
- **请求保持条件**:一个进程因为请求资源而阻塞时，不释放自己持有的资源
- **循环等待**:存在进程资源的循环等待链（循环等待是死锁的必要不充分条件）

**死锁的处理策略**

1. **预防死锁**:破坏死锁产生的四个必要条件中的一个或多个。
   
   - 破坏互斥条件:将只能互斥适用的资源改成共享适用，这种方法的缺点是:并不是所有的资源都可以改造成可共享使用的资源，**可行性不高**。
   - 破坏不可剥夺条件
     ![image-20220601160710437](/Users/userli/Desktop/imgs_typora/image-20220601160710437.png)
   - 破坏请求和保持条件:采用**静态分配法**，即进程在运行前一次申请完所有内存。但缺点也很明显:有些资源可能只需要用很短的时间，因此如果进程的整个运行期间都一直保持着所有资源，就会造成严重的资源浪费，**资源利用率极低**。并且，该策略也有可能导致某些进程**饥饿**。
   - 破坏循环等待条件:采用顺序资源分配法。

2. **避免死锁**:
   
   避免死锁是在资源动态分配过程中，防止系统进入不安全状态，以避免发生死锁，比如银行家算法。
   
   安全序列:如果系统按照某种序列分配资源可以使每个进程都能顺利完成，那么这种序列就是安全序列，系统就是**安全状态**。
   
   如果系统处于安全状态，就一定不会发生死锁。如果系统进入不安全状态，则有可能发成死锁，因此可以**在资源为分配之前预先判断这次分配是否会导致系统进入不安全状态**，以此决定是否答应资源分配请求。

3. **死锁的检测**（资源分配图）和**解除**（资源剥夺法，撤销进程法，进程回退法）

### 6. 简述下银行家算法★★★★✅

银行家算法是一种避免死锁的算法，其思想是，将操作系统看作银行，把操作系统管理的资源看作银行家管理的资金，进程向操作系统请求分配资源相当于用户向银行家贷款。进程在运行之前先声明对各种资源的最大需求量，当进程在执行中继续申请资源时，先测试该进程已占用的资源数与本次申请的资源数之和是否超过该进程声明的最大资源量。若超过则拒绝分配，若未超过则再测试系统现存的资源能否满足该进程尚需的最大资源量，若能则按照当前的申请量分配资源，否则推迟分配。

银行家算法会预先判断该次分配是否会使系统进入不安全状态。

安全状态就是只系统能按某种进程推进顺序为每个进程分配所需的资源，直至满足每个进程对资源的最大需求，使每个进程都可以顺序完成。

### 7. 介绍下几种常见的进程调度算法及其流程（FCFS，SJF，剩余短作业优先，优先级调度，轮转法，多级反馈队列等等）★★★★★★✅

**进程调度策略**

1. **先来先服务（FCFS）**
   
   根据进程到达的先后顺序执行进程，不考虑等待时间和执行时间，**不会产生饥饿现象**。属于**非抢占**式调度，优点是**公平，实现简单**；缺点是**不利于短作业**。

2. **短作业优先（SJF）**
   
   该算法是从进程等待队列中选择一个运行时间最短的进程，将它们调入内存运行 。
   
   - SJF非抢占，SRTN（最短剩余时间优先算法）为抢占式
   - 优点**:最短平均等待时间**与**最短平均周转时间**
   - 缺点:对短作业有利，对长作业不利
   - 可能导致饥饿现象

3. **高响应比优先（HRRN）**
   
   高响应比优先算法在等待时间相同的情况下，作业执行的时间越短，响应比越高。短任务优先，同时响应比会随着等待时间增加而变大，优先级会提高，能够避免饥饿现象。优点是兼顾长短作业，缺点是计算响应比开销大，适用于批处理系统。
   
   - $响应比=\frac{等待时间+服务时间}{服务时间}$
   - 非抢占式
   - 不会导致饥饿

4. **时间片轮转算法（RR）**
   
   按照先来先服务的原则，使每个进程轮流获得固定的处理机时间片，这样就可以保证就绪队列中的所有进程在一给定的时间内均能获得操作系统的响应。
   
   系统将所有的就绪进程按先来先服务的原则排成一个队列，每次调度时，把CPU分配给队首进程，并令其执行一个时间片。当执行的时间片用完时，由一个计时器发出时钟中断请求，调度程序便据此信号来停止该进程的执行，并将它送往就绪队列的末尾；然后，再把处理机分配给就绪队列中新的队首进程，同时也让它执行一个时间片。这样就可以保证就绪队列中的所有进程在一给定的时间内均能获得一时间片的处理机执行时间。也就是说，系统能在给定的时间内响应所有用户的请求。
   
   - 抢占式
   - 如果时间片过大，则RR退化为FCFS，会增大进程的响应时间；如果时间片过小，则进程切换频繁，增大系统开销
   - 优点:公平，**响应快**，适用于分时操作系统
   - 缺点:高频率的进程切换会带来一定的开销，并且不会区分任务的紧急程度
   - 不会导致饥饿

5. **优先级调度算法**
   
   - 优先级分为静态优先级（进程创建时确定优先级）和动态优先级（进程运行时动态调整优先级）
   - 优点:用优先级区分紧急程度，适用于实时操作系统，可以**灵活**的调整对各种作业/进程的偏好程度。
   - 会导致饥饿

6. **多级反馈队列调度算法**、
   
   将时间片轮转与优先级调度相结合，把进程按优先级分成不同的队列，先按优先级调度，优先级相同的，按时间片轮转。优点是兼顾长短作业，有较好的响应时间，可行性强，适用于各种作业环境
   
   - 抢占式算法
   - 会导致饥饿

### 8. 内存管理:分页，分段，段页，分页与分段的区别★★★✅

连续内存分配:单一连续分配，固定分区分配，动态分区分配

非连续内存分配:分页，分段，段页

**为什么需要三种管理方式**

由于连续内存分配方式会导致内存利用率偏低以及内存碎片的问题，因此需要对这些离散的内存进行管理。引出了三种内存管理方式。

**分页存储管理**

把主存空间划分为大小相等的块，作为主存的基本单位。每个进程也以块为单位进行划分。进程在执行时，以块为单位逐个申请主存中的块空间。

1. 基本分页存储管理中不具备页面置换功能，因此需要整个程序的所有页面都装入内存之后才可以运行。

2. 需要一个页表来记录逻辑地址和实际存储地址之间的映射关系，以实现从页号到物理块号的映射。

3. 由于页表也是存储在内存中的，因此内存数据需要两次的内存访问(一次是从内存中访问页表，从中找到指定的物理块号，加上页内偏移得到实际物理地址；第二次就是根据第一次得到的物理地址访问内存取出数据)。 

4. 为了减少两次访问内存导致的效率影响，分页管理中引入了快表（高速缓冲存储器00），当要访问内存数据的时候，首先将页号在快表中查询，如果在快表中，直接读取相应的物理块号；如果没有找到，那么访问内存中的页表，从页表中得到物理地址，同时将页表中的该映射表项添加到快表中。 

5. 在某些计算机中如果内存的逻辑地址很大，将会导致程序的页表项会很多，而页表在内存中是连续存放的，所以相应的就需要较大的连续内存空间。为了解决这个问题，可以采用两级页表或者多级页表的方法，其中外层页表一次性调入内存且连续存放，内层页表离散存放。相应的访问内存页表的时候需要一次地址变换，访问逻辑地址对应的物理地址的时候也需要一次地址变换，而且一共需要访问内存3次才可以读取一次数据。

**分段存储管理**

分页是从计算机的角度考虑，是为了提高内存利用率。而分段是为了满足程序员在编写代码的时候的一些逻辑需求(比如数据共享，数据保护，动态链接等)。

1. 分段内存管理当中，地址是二维的，一维是段号，一维是段内地址；

2. 其中每个段的长度是不一样的，而且每个段内部都是从0开始编址的。由于分段管理中，每个段内部是连续内存分配，但是段和段之间是离散分配的，因此也存在一个逻辑地址到物理地址的映射关系，相应的就是段表机制。段表中的每一个表项记录了该段在内存中的起始地址和该段的长度。段表可以放在内存中也可以放在寄存器中。

3. 访问内存的时候根据段号和段表项的长度计算当前访问段在段表中的位置，然后访问段表，得到该段的物理地址，根据该物理地址以及段内偏移量就可以得到需要访问的内存。

**分页与分段管理的区别**

1. **页是信息的物理单位**，分页是为了实现非连续分配，以便解决内存碎片问题，提高内存利用率；分页出于系统管理的需要。**段是信息的逻辑单位**，它按照用户进程中的自然段划分逻辑空间，分段的目的是为了更好地实现共享，满足用户的需要。 
2. 页的大小固定且由系统确定，系统把逻辑地址划分为页号和页内地址两部分，这是由硬件实现的，因而在系统中只能有一种大小的页面。而段的长度不固定，取决于用户所编写的程序，通常由编译程序在对源程序进行编译时根据信息的性质来划分。 
3. 分页的作业地址空间是一维的；分段的地址空间是二维的，需要知道段名和段内地址。
4. 分页有内部碎片，分段有外部碎片。

**段页式存储管理**

先将用户程序分为若干个段，然后再把每个段分成若干个页，并且为每一个段赋予一个段名称。这样在段页式管理中，一个内存地址就由段号，段内页号以及页内地址三个部分组成。

段页式内存访问:系统中设置了一个段表寄存器，存放段表的起始地址和段表的长度。地址变换时，根据给定的段号以及段表起始地址，就可以得到该段对应的段表项，从段表项中得到该段对应的页表的起始地址，然后利用逻辑地址中的段内页号从页表中找到页表项，从该页表项中的物理块地址以及逻辑地址中的页内地址拼接出物理地址，最后用这个物理地址访问得到所需数据。由于访问一个数据需要三次内存访问，所以段页式管理中也引入了高速缓冲寄存器。

### 10. 什么是虚拟内存？什么是共享内存？★★★✅

**虚拟内存**是一种内存分配方案，是一项可以用来**辅助内存分配**的机制，通过把一部分暂时不用的内存信息放到硬盘上。

虚拟内存是操作系统为每个进程提供的一种抽象，每个进程都有属于自己的、私有的、地址连续的虚拟内存，**页表**中记录了虚拟内存地址到物理内存地址的映射关系，通过**地址空间映射**就可以知道虚拟地址空间中的某个数据被放到了哪个物理内存地址上。

每个进程都有自己的虚拟地址空间，进程内的所有线程共享进程的虚拟地址空间。

在操作系统中，进程是以页为单位加载到内存中的，**按需分页**是一种虚拟内存的管理方式。在使用请求分页的系统中，只有在尝试访问页面所在的磁盘并且该页面尚未在内存中时，也就发生了**缺页异常**，操作系统才会将磁盘页面复制到内存中。

**共享内存**是进程间通信机制。操作系统在几个进程的地址空间上映射一段内存，然后这几个进程可以在不需要调用操作系统函数的情况下在那段内存上进行读/写操作

### 11. 有哪些页面置换算法？★★★★✅

请求分页存储管理中，若内存空间不够，由操作系统负责将内存中暂时用不到的信息换出到外存，这是需要用到页面置换算法决定应该换出那个页面。

##### 3.1 最佳置换算法（OPT）

每次选择淘汰的页面是**未来**最长时间内不再被访问的页面

##### 3.2 先进先出置换算法（FIFO）

每次选择淘汰的页面是最早进入内存的页面

只有FIFO算法会产生**Belady异常**（当为进程分配的物理块数增大时，缺页次数不减反增的现象）。由于该算法与进程实际运行时的规律不适应，因为先进入的页面也有可能最先被访问，因此，**算法性能差**。

违背了局部性原理:

- 时间局部性:程序某条指令执行之后，不久之后可能再次执行；某数据访问之后，不久之后可能再次访问；时间局部性的原因是因为程序中存在大量循环
- 空间局部性，程序访问某个存储单元之后，不久之后，其附近的存储单元可能被访问。

##### 3.3 最近最久未使用置换算法（LRU）

每次淘汰的页面是最近最久未使用的页面。

##### 3.4 时钟置换算法（CLOCK）

- OPT:性能最好，但无法实现
- FIFO:实现简单，但算法性能差（Belady异常）
- LRU:性能好，是最接近OPT算法性能的，但实现起来需要专门的硬件支持，算法开销大。

CLOCK算法又叫**最近未用算法（NRU）**

![image-20220601175333176](/Users/userli/Desktop/imgs_typora/image-20220601175333176.png)

### 13. 磁盘调度算法以及磁盘空间存储管理？★★★★

磁盘调度算法的目的很简单，就是为了**提高磁盘的访问性能**，一般是通过**优化磁盘的访问请求顺序**来做到的。

https://blog.csdn.net/lishanleilixin/article/details/89709194

1. 先来先服务（FCFS）
2. 最短寻道时间优先（SSTF）
3. 扫描算法（SCAN）
4. 循环扫描算法（C-SCAN）

### 15. 堆栈的区别★★★★★★✅

**堆栈操作系统区别**:

1. 栈:由操作系统自动分配释放，存放函数的参数值，局部变量的值等。

2. 堆:一般由程序员申请释放，比如通过malloc或者new进行申请，通过free和delete进行释放。分配方式类似于链表.（[new,malloc的区别](https://blog.csdn.net/nie19940803/article/details/76358673)）。
   
   > **操作系统有一个记录空间内存地址的链表**，当系统收到程序的申请时，会遍历链表，**寻找第一个空间大于所申请空间的堆节点，然后将节点从内存空闲节点链表中删除，并将该节点的空间分配给程序**。

**堆栈数据结构区别**:

堆**:堆是用完全二叉树的结构来维护的一维数组**。堆的父结点的键值或索引总是小于（或者大于）它的子节点，大于的话为大顶堆，小于的话为小顶堆

栈:是一种后进先出的数据结构，只允许在表的末端进行插入和删除的线性表

## 计算机组成原理

### 1. 总线

总线是连接多个设备或者接入点的数据传输通路

### 1. 冯诺依曼机的体系结构★★★★★

主要由五大部件组成

1. 存储器用来存放数据和程序

2. 运算器主要运行算数运算和逻辑运算，并将中间结果暂存到运算器中

3. 控制器主要用来控制和指挥程序和数据的输入运行，以及处理运算结果

4. 输入设备用来将人们熟悉的信息形式转换为机器能够识别的信息形式，常见的有键盘，鼠标等

5. 输出设备可以将机器运算结果转换为人们熟悉的信息形式，如打印机输出，显示器输出等

### 2.衡量计算机性能指标★★★★

### 3.原码. 反码. 补码★★★

一个数在计算机中的二进制表示形式, 叫做这个数的机器数。机器数是带符号的，在计算机用一个数的最高位存放符号, 正数为0, 负数为1.

因为第一位是符号位，所以机器数的形式值就不等于真正的数值。例如上面的有符号数 10000011，其最高位1代表负，其真正数值是 -3 而不是形式值131（10000011转换成十进制等于131）。所以，为区别起见，将带符号位的机器数对应的真正数值称为机器数的真值。

原码就是符号位加上真值的绝对值, 即用第一位表示符号, 其余位表示值. 

反码的表示方法是: 正数的反码是其本，负数的反码是在其原码的基础上, 符号位不变，其余各个位取反.

补码的表示方法是:正数的补码就是其本，负数的补码是在其原码的基础上, 符号位不变, 其余各位取反, 最后+1. (即在反码的基础上+1)

https://www.cnblogs.com/zhangziqiu/archive/2011/03/30/computercode.html

### 4. 奇偶校验. 汉明码校验，循环冗余校验★★

### 5. 存储器的分类（RAM. DAM的区别）★★

### 6. 段页式虚拟内存★★★

### 7. cpu一个指令周期的流程是什么？★★★★★

## 数据库

### 1. 一二三范式★★★★★

第一范式 (1NF) 

属性不可分。即数据库表的每一列都是不可分割的基本数据项，同一列中不能有多个值，即实体中的某个属性不能有多个值或者不能有重复的属性。 

第二范式 (2NF) 

每个非主属性完全函数依赖于键码。可以通过分解来满足 2NF。 

第三范式 (3NF) 

非主属性不传递函数依赖于键码。简而言之，第三范式就是属性不依赖于其它非主属性。 

### 1. SQL查询语句★★

### 1. 数据库有什么类型的数据库. 关系型数据库的特点★★★★

### 1. 数据库有几种锁？★★★

共享（S)锁:多个事务可封锁一个共享页；任何事务都不能修改该页； 通常是该页被读取完毕，S锁立即被释放。 

排它（X)锁:仅允许一个事务封锁此页；其他任何事务必须等到X锁被释放才能对该页进行访问；X锁一直到事务结束才能被释放。 

更新（U)锁:用来预定要对此页施加X锁，它允许其他事务读，但不允许再施加U锁或X锁；当被读取的页将要被更新时，则升级为X锁；U锁一直到事务结束时才能被释放。

### 2. 数据库的三个完整性约束★★★★

实体完整性，参照完整性和用户自定义完整性约束。实体完整性规定表的每一行在表中是唯一的实体。

参照完整性指两个表的主关键字和外关键字的数据一致，保证表之间的数据一致性，防止数据丢失或无意义的数据在数据库中扩散。

用户自定义完整性是不同数据库根据应用环境不同，用户定义的一些特殊约束条件。

### 1. 事务与锁？什么是事物？什么事锁？事务的四个特性是什么？★★★★★

**什么是事务？**

事务是指作为单个逻辑工作单元执行的一系列操作，要么完全地执行，要么完全地不执行。  事务处理可以确保除非事务性单元内的所有操作都成功完成，否则不会永久更新面向数据的资源。通过将一组相关操作组合为一个要么全部成功要么全部失败的单元，可以简化错误恢复并使应用程序更加可靠。

**什么是锁？**

锁是用于解决隔离性的一种机制。事务的隔离级别通过锁的机制来实现。

**事物的四个特性（ACID）**:

原子性（Atomicity）:事务开始后所有操作，要么全部做完，要么全部不做，不可能停滞在中间环节。事务执行过程中出错，会回滚到事务开始前的状态，所有的操作就像没有发生一样。也就是说事务是一个不可分割的整体，就像化学中学过的原子，是物质构成的基本单位。

一致性（Consistency）:事务开始前和结束后，数据库的完整性约束没有被破坏 。比如A向B转账，不可能A扣了钱，B却没收到。

隔离性（Isolation）:同一时间，只允许一个事务请求同一数据，不同的事务之间彼此没有任何干扰。比如A正在从一张银行卡中取钱，在A取钱的过程结束前，B不能向这张卡转账。

持久性（Durability）:事务完成后，事务对数据库的所有更新将被保存到数据库，不能回滚。

链接:

1.https://blog.csdn.net/qq_37206355/article/details/105475028

2.https://www.cnblogs.com/tjw-bk/p/13974795.html

### 1. 存储过程是什么？触发器是什么？为什么要使用存储过程？★★★

存储过程（Stored Procedure）是在大型[数据库系统](https://baike.baidu.com/item/数据库系统/215176)中，一组为了完成特定功能的SQL 语句集，它存储在数据库中，一次[编译](https://baike.baidu.com/item/编译/1258343)后永久有效，用户通过指定存储过程的名字并给出参数（如果该存储过程带有参数）来执行它。存储过程是数据库中的一个重要对象。在数据量特别庞大的情况下利用存储过程能达到倍速的效率提升。

触发器（trigger）是SQL server 提供给[程序员](https://baike.baidu.com/item/程序员/62748)和数据分析员来保证[数据完整性](https://baike.baidu.com/item/数据完整性/110071)的一种方法，它是与表事件相关的特殊的存储过程，它的[执行](https://baike.baidu.com/item/执行/3166225)不是由程序调用，也不是手工启动，而是由事件来触发，[比如](https://baike.baidu.com/item/比如)当对一个表进行操作（ insert，delete， update）时就会激活它执行。触发器经常用于加强数据的完整性约束和业务规则等。

存储过程处理比较复杂的业务时比较实用。 比如说，一个复杂的数据操作。如果你在前台处理的话。可能会涉及到多次数据库连接。但如果你用存储过程的话。就只有一次。从响应时间上来说有优势。 也就是说存储过程可以给我们带来运行效率提高的好处。 另外，程序容易出现 BUG 不稳定，而存储过程，只要数据库不出现问题，基本上是不会出现什么问题的。也就是说从安全上讲，使用了存储过程的系统更加稳定。

1.存储过程只在创造时进行编译，以后每次执行存储过程都不需再重新编译，而一般 SQL 语句每执行一次就编译一次,所以使用存储过程可提高数据库执行速度。 2.当对数据库进行复杂操作时(如对多个表进行 Update,Insert,Query,Delete 时），可将此复杂操作用存储过程封装起来与数据库提供的事务处理结合一起使用。这些操作，如果用程序来完成，就变成了一条条的 SQL 语句，可能要多次连接数据库。而换成存储，只需要连接一次数据库就可以了。 3.存储过程可以重复使用,可减少数据库开发人员的工作量。 4.安全性高,可设定只有某此用户才具有对指定存储过程的使用权。　

存储过程的缺点 1:调试麻烦，但是用 PL/SQL Developer 调试很方便！弥补这个缺点。 　　 2:移植问题，数据库端代码当然是与数据库相关的。但是如果是做工程型项目，基本不存在移植问题。 　　 3:重新编译问题，因为后端代码是运行前编译的，如果带有引用关系的对象发生改变时，受影响的存储过程、包将需要重新编译（不过也可以设置成运行时刻自动编译）。 4:如果在一个程序系统中大量的使用存储过程，到程序交付使用的时候随着用户需求的增加会导致数据结构的变化，接着就是系统的相关问题了，最后如果用户想维护该系统可以说是很难很难、而且代价是空前的。维护起来更加麻烦！

### 1. 数据库的ACID特性，事务回滚，如何解决数据的不一致？事务的ACID特性怎么保证？（REDO/UNDO机制）★★★

### 2. Mysql的存储引擎及区别★★★

### 1. 如何优化数据库？提高查询的效率？★★★★★★

## 软件工程

### 1. 什么是软件工程？软件工程三要素？★★★

软件工程三要素包括:方法. 工具和过程。

### 2. 软件生存周期？★

### 3. 软件开发模型？★

### 4. 黑盒测试和白盒测试有什么区别？★★★

### 5. 敏捷开发和瀑布模型的区别★

### 6. 配置管理包括哪些活动★

### 7. 持续集成及其特性★

### 8. 说一个你了解的设计模式？结合项目举个例子？★★★★★★

### 9. 介绍下MVC模式★★★★

## 算法分析与设计

### 动态规划和分治. 贪心相比有什么区别？各自的优缺点？

## 编程语言

### 1. 指针和引用的区别★★★★★

### 2. 浅拷贝和深拷贝★★★

### 3. 程序的编译执行过程★★★★★★

### 4. 知道c++中的符号重载吗？★★★

### 5. C++中如何实现多态？★★★

### 6. java和c++和c的区别（准备下英文）★★★★★★

1. Java不能在类之外的地方定义全局变量，只能在一个类中定义静态变量来实现一个全局变量。C/C++可以直接在类之外定义全局变量。
   
   Java can't define global variables outside a class, it can only define static variables in a class as a global variable.

2. Java不支持C/C++的goto语句，而是通过try、catch来代替C/C++的goto来处理异常时控制。
   
   Java doesn't support "goto" statements of C/C++, but uses try/catch syntax instead of "goto" for exception control.

3. C/C++可以通过指针进行内存地址操作，例如通过指针对某内存地址进行显式类型转换，而这种操作访问私有成员破坏了安全性；
   
   Java对指针进行完全的控制，不能在程序中进行任何指针操作，Java中的数组作为类实现，解决了关于数组的很多C/C++难以检查的错误。
   
   C/C++ can operate memory address through pointer. For Example, C/C++ makes explicitly conversion to a memory address by pointer, which destroys the security of the program because it accesses private members. Java Controls pointer completely, and can not operate any pointer in the program. The array in Java is implemented as a class, which solves many errors about array which are difficult to check in c/c++.

4. 在C语言中通过malloc和free函数分配和释放内存；C++中可以通过new和delete进行内存的分配和释放。在Java中通过new运算符分配内存，进行对象实例化，而分配内存时随着程序运行动态分配，且Java能够进行自动管理和自动垃圾回收，防止内存资源产生的操作错误和浪费。
   
   In C language, malloc function and free function are used to allocate and release memory; In C + +, memory can be allocated and released by new and delete keywords. In Java, the new operator is used to allocate memory and instantiate objects, and the allocated memory is dynamically allocated with the running of the program. Java can automatically manage memory and recycle garbage, so as to prevent memory operation errors and memory waste.

5. C/C++对于不同的平台，数据类型的长度不同，代码不可移植。Java对数据类型总是分配固定长度位数，保证平台无关性。
   
   The length of data type of C/C++ is different in different platforms, so the code is not portable. Java always allocates a fixed number of bits to data type to ensure platform independence.

6. C++可以通过指针进行任意类型的转换，Java在进行类型转换时会进行类型相容性检查，防止不安全的转换。
   
   C++ can do any type conversion by pointer. Java will check the type compatibility to prevent unsafe conversion.

7. C/C++中用头文件声明类的原型及全局变量、库函数，在大的系统中难以维护这些文件。Java不支持头文件，所有类成员的类型和访问权限都封装在一个类中，运行时系统对访问会进行控制防止对私有成员的操作；导入其他类要使用import语句。
   
   In C/C++, header files are used to declare class prototypes, global variables and library functions, which are diffcult to maintain in large systems. Java does not support header files. The types and access rights of all class members are encapsulated in one class. When the program is running, the system will control the access to prevent the operation of private members.

### 7. Java的垃圾回收算法★★★

### 8. Jvm的内存管理★★★

### 9. 全局变量是好是坏？★★

### 10. 什么是JDK

### 11. python

## 微积分

### [欧拉回路](https://www.cnblogs.com/wkfvawl/p/9626163.html)

欧拉回路:图G的一个回路，如果恰通过图G的每一条边，则该回路称为欧拉回路，具有欧拉回路的图称为欧拉图。欧拉图就是从图上的一点出发，经过所有边且只能经过一次，最终回到起点的路径。

欧拉通路:即可以不回到起点，但是必须经过每一条边，且只能一次。也叫"一笔画"问题。

### 欧氏距离及常见距离公式的缺点？★★★★★

欧氏距离也就是n维空间中两点之间的线段长度。

1 欧氏距离的缺点在于，会受到数据尺度的影响而产生偏斜，需要对数据进行归一化后使用。

2 余弦相似距离缺点在于只考虑了数据的方向，而没考虑向量的大小，受到数据尺度的影响较大。

3 曼哈顿距离就是街道距离，缺点在于不够直观，并且距离不是最短距离。

---

### 1. 函数的零点和极值点

**零点**:求解析解:令函数值等于0，然后解方程得到零点；对于过于复杂无法求方程解的情况，使用数值方法:二分法、牛顿迭代法

**极值点**:对函数求导，然后令导函数等于0，按照上述方法求导函数的零点即可，对于所得零点判断解的两端导函数值的符号，若两端同号，所得的解是驻点，若两端异号，则是极值点。

### 2. 导数，偏导数

导数代表的是曲线在某一点的斜率，是函数的变化率，在更高维度的空间中，偏导数就是含有多个自变量时，函数对某坐标轴的变化率.

**导数**:代表一元函数的变化率，如果y=f(x)在某一点$x_0$处有定义，并且如果$\Delta$y与$\Delta$x的比值在$\Delta$x$\rightarrow$0的时候极限存在，则称f(x)在$x_0$处可导，这个极限称为f(x)在$x_0$处的导数。

### 3. 三个中值定理

**罗尔中值定理**:函数f(x)在闭区间连续，开区间可导，区间端点函数值相等，必存在一点导数值为0

**拉格朗日中值定理**:函数f(x)在闭区间连续，开区间可导，必存在一点导数值等于端点连线的斜率。

**柯西中值定理**:函数f(x)和g(x)在闭区间连续，开区间可导，且任意一点g(x)导数值不为0，必存在一点，f(x)导函数和g(x)导函数的比值，等于两函数区间端点函数值之差的比值。

**区别在于，**罗尔定理要求区间端点函数值相等，拉格朗日中值定理则不要求。柯西中值定理关系到两个函数

**联系在于，**柯西中值定理当g(x)=x的时候，退化为拉格朗日中值定理，拉格朗日中值定理的区间端点函数值相等的时候，退化为罗尔中值定理。

**物理意义在于，**罗尔定理表明往复运动的始终必存在某一时刻速度为0。拉格朗日中值定理表明一段物体从一个地方移动到另一个地方的始终，中间必有一点加速度为0。柯西中值定理表明一段曲线运动的过程中，必有一点速度方向和位移方向相同。

### 4. 泰勒函数

**泰勒展开**可以把一个在x=x0处具有n阶导数的函数f(x)展开成关于(x - x0)的n次多项式，其系数为f(x)在x0处的各阶导数值，从而得到f(x)在某点及其附近信息的近似描述。

### 5. 偏导数

**偏导数**:代表多元函数对某个变量的变化率，比如二元函数z=f(x, y)，固定y，只让x单独变化，从而看成是关于x的一元函数的变化来研究，

### 6. 方向导数，梯度

**方向导数**:函数沿任意方向的变化率

**梯度**:是一个向量，指向使函数增加最快的方向，其大小是函数的最大增长率，即方向导数的最大值

### 7. 曲线积分与曲面积分

1. 第一型曲线积分:线的质量
   
   线:$f(x)$
   
   质量:$g(x)$
   
   线的质量:$\int_Lg(x)ds = \int_\alpha^\beta g(x)\sqrt{1 + (f'^2(x))}dx$

2. 第二型曲线积分:力沿线做的功
   
   $\int_{\mathop{\frown}\limits_{AB}}Pdx + Qdy + Rdz$（参数方程求解）

3. 格林公式:将平面闭曲线上的曲线积分与平面区域上的二重积分联系起来
   
   ![{\displaystyle \iint \limits _{D}\left({\frac {\partial Q}{\partial x}}-{\frac {\partial P}{\partial y}}\right)\mathrm {d} x\mathrm {d} y=\oint _{L^{+}}(P\mathrm {d} x+Q\mathrm {d} y)}](https://wikimedia.org/api/rest_v1/media/math/render/svg/a882d66ae2bfab878d915f7e7e46ccf5227c7f52)

4. 第一型曲面积分:曲面的质量
   
   $\iint_S f(x, y, z)dS = \iint_Df[x, y, z(x, y)]\sqrt{1 + z_x^2 + z_y^2}dxdy$

5. 第二型曲面积分:有方向的流体通过曲面的流量
   
   $\iint_SFn_0dS = \iint_S(Pcos\alpha + Qcos\beta + Rcos\gamma)dS = \iint_SPdxdy + Qdxdz + Rdxdy$

6. 高斯公式:将空间曲面上的曲面积分与所围区域的三重积分联系起来
   
   ![\iiint _{{\Omega }}\left({\frac  {\partial P}{\partial x}}+{\frac  {\partial Q}{\partial y}}+{\frac  {\partial R}{\partial z}}\right)dv=](https://wikimedia.org/api/rest_v1/media/math/render/svg/a5790b8c36dfe5a9a16f7e44f154d279452b64a2){\displaystyle \oiint }![\oiint](https://upload.wikimedia.org/wikipedia/commons/thumb/8/86/OiintLaTeX.svg/25px-OiintLaTeX.svg.png){\displaystyle \scriptstyle \Sigma }![\scriptstyle \Sigma ](https://wikimedia.org/api/rest_v1/media/math/render/svg/ce5b381f6640ccb0f35cac475885800035f066d5){\displaystyle P\,dy\land dz+Q\,dz\land dx+R\,dx\land dy}![{\displaystyle P\,dy\land dz+Q\,dz\land dx+R\,dx\land dy}](https://wikimedia.org/api/rest_v1/media/math/render/svg/9bd8a28df1d83ec725ff3123f6c8113651df9071)

### 7. 格林公式

将平面闭曲线上的第二型曲线积分和闭曲线所谓成的平面区域上的二重积分联系起来。

### 8. 高斯公式，通量，散度

https://www.zhihu.com/question/24074028

**高斯公式**:建立了体积分和面积分之间的联系，将空间曲面上的曲面积分与所围区域的三重积分联系起来

**通量**:向量场A通过指定曲面的流量

**散度**:${\frac  {\partial P}{\partial x}}+{\frac  {\partial Q}{\partial y}}+{\frac  {\partial R}{\partial z}}$，又叫通量密度

格林公式和高斯公式都是区域上的积分与区域边界之间的关系。

散度表征空间各点矢量场发散的强弱程度，物理上，散度的意义是场的 有源性（源的强度）。当 div F>0 ，表示该点有散发通量的正源（发散源）；当 div F<0 表示该点有吸收通量的负源（洞或汇）；当 div F=0，表示该点无源。

### 9. 斯托克斯公式，环流量，旋度

**斯托克斯公式**:将曲面上的曲面积分与曲面边界上的曲线积分之间联系起来。
$$
\iint_{\Sigma}\begin{vmatrix} \cos \alpha & \cos \beta & \cos \gamma \\ \frac{\partial}{\partial x} & \frac{\partial}{\partial y} & \frac{\partial}{\partial z} \\ P & Q & R \end{vmatrix}dS=\oint_{\Gamma}Pdx+Qdy+Rdz
$$
**环流量**:第二型曲线积分

**旋度**:又叫环量密度，向量场的旋度记为:
$$
rotA = (\frac{\partial R}{\partial y} - \frac{\partial Q}{\partial z})i + (\frac{\partial P}{\partial z} - \frac{\partial R}{\partial x})i + (\frac{\partial Q}{\partial x} - \frac{\partial P}{\partial y})k= \begin{vmatrix} \cos \alpha & \cos \beta & \cos \gamma \\ \frac{\partial}{\partial x} & \frac{\partial}{\partial y} & \frac{\partial}{\partial z} \\ P & Q & R \end{vmatrix}
$$

旋度表示三维向量场对某一点附近的微元造成的旋转程度，这个向量提供了向量场在这一点的旋转性质

![image-20220615161556930](/Users/userli/Desktop/imgs_typora/image-20220615161556930.png)

### 10. 无穷级数

#### 绝对收敛，条件收敛

#### 傅立叶级数

### 11. 可导. 可微. 连续. 可积之间的关系（一元函数+二元函数）★★★

导数描述对的是函数的变化速率，微分描述的是函数的变化幅度

可偏导:函数对该点所有变量的偏导数都存在

 **一元函数**:

- 可微和可导等价
- 可导必连续，连续不一定可导
- 连续必可积，可积不一定连续

**二元函数**:

- 可微一定连续，可微一定可偏导

![image-20220615115451468](/Users/userli/Desktop/imgs_typora/image-20220615115451468.png)

### **梯度下降**

- - 损失函数就是一个自变量为算法的参数，函数值为误差值的函数。梯度下降就是找让误差值最小时候算法取的参数。
  - **梯度下降作用**是找到函数的最小值所对应的自变量的值（曲线最低点对应x的值）。
  - **梯度下降含义（具体操作）是**:改变x的值使得导数的绝对值变小，当导数小于0时候（情况1），我们要让目前x值大一点点，再看它导数值。当导数大于0时候（情况2），我们要让目前x值减小一点点，再看它导数值。**当导数接近0时候，我们就得到想要的自变量x了。也就是说找到这个算法最佳参数**，使得拟合曲线与真实值误差最小。（**理解这段话，就不用硬背公式啦**）

---

## 概率论

[详解最大似然估计（MLE）、最大后验概率估计（MAP），以及贝叶斯公式的理解](https://blog.csdn.net/u011508640/article/details/72815981)

### 1. 大数定律

https://zhuanlan.zhihu.com/p/77312635

大数定理简单来说，指得是某个随机事件在单次试验中可能发生也可能不发生，但在大量重复实验中往往呈现出明显的规律性，即该随机事件发生的频率会向某个常数值收敛，该常数值即为该事件发生的概率。

另一种表达方式为当样本数据无限大时，样本均值趋于总体均值。

**大数定律告诉我们能用频率近似代替概率；能用样本均值近似代替总体均值。**

### 2. 中心极限定理

https://zhuanlan.zhihu.com/p/25241653

中心极限定理指的是给定一个任意分布的总体。我每次从这些总体中随机抽取 n 个抽样，一共抽 m 次。 然后把这 m 组抽样分别求出平均值。 这些平均值的分布接近正态分布。

### 3. 极大似然估计★★★★★

https://zhuanlan.zhihu.com/p/26614750

极大似然估计，通俗理解来说，**就是利用已知的样本结果信息，反推最具有可能导致这些样本结果出现的模型参数值！**

### 4. 变量与随机变量有什么区别？★★

随机变量能够描述随机现象，并通过概率统计的方法进行分析。而变量通常用来描述确定性的现象。

变量的取值是固定唯一的，并且取值范围是整个定义域。而随机变量取值有多个，而且每个取值都有一定的概率。在试验之前，随机变量的取值是不能预知的，试验之后，随机变量的取值范围就是这次试验的样本空间。

### 2. 随机变量与概率分布有什么联系？★★

随机变量的分布函数表述了随机变量的统计规律性，已知一个随机变量的分布函数就可以得知该随机变量落在某一区间的概率。

### 3. 联合概率与边缘概率有什么区别？有什么联系？★★

**区别**:

1. 联合概率是基于两个随机变量及其相互作用的样本空间的概率。

2. 边缘概率是多维随机变量的样本空间中，某一个或多个随机变量构成的子空间的概率。

**联系**:在联合概率的基础上固定若干个随机变量的取值便得到边缘概率。

### 4. 常见的概率分布有哪些？有什么应用场景？请举例说明★★

二项分布:常用于检查产品合格率、色盲率调查等等

两点分别:比赛胜率估计

泊松分布:常用于一天内到达顾客数、铸件上的砂眼数、一天内电路受到电磁波干扰次数等等

超几何分布:用于进行有限总体中进行不放回抽样。

几何分布:一次伯努利试验中事件A首次出现时的试验次数。例如产品不合格率调查。

正态分布:主要应用于统计理论、误差理论等等

指数分布:常用于随即服务系统、寿命估计、排队论等等

### 5. 高斯分布(正态分布) ★★★★

### 7. 大数定律和中心极限定理的意义与作用（切比雪夫大数定律）★★★★

辛钦大数定理:说明了对于独立同分布且具有均值u的n个随机变量，当n很大的时候它们的算术平均值依概率收敛于u。

伯努利大数定律表明只要随机试验的次数n充分大，那么事件A频率和概率的绝对偏差很小，说明在实际应用中，试验次数很大的时候可以用事件的频率来替代事件的概率。

独立同分布的中心极限定理:均值为u，标准差为sigma的独立同分布的n个随机变量之和的标准化变量在n充分大的时候近似服从于标准正态分布。

### 8. 正态分布的和还是正态分布吗，正态分布性质与独立同分布）★★★★★

彼此独立的正态分布的和仍然是正态分布，这叫做正态分布的可加性。

正态分布的可加性就是:如果多个随机变量分别服从不同的正态分布，如果这些随机变量彼此独立，那么这些随机变量的和也服从正态分布。

### 9. 数学期望和方差？★★

**随机变量的数学期望**就是随机变量每个取值于该取值的概率的乘积的累加和。它描述了随机变量的集中特性。

**随机变量的方差**描述了随机变量的波动特性，即离散特性，其定义是随机变量的每个取值和数学期望的偏差平方和与该取值的概率的乘积的连加和。

### 10. 独立和不相关的区别？★★

> ??????????????独立一定不相关，而不相关不一定独立。例如线性不相关的随机变量可能是非线性相关。最常见的例子就是Logistics函数或者二次函数，自变量和因变量计算所得相关系数很低，但是是互相依赖的变量。

### 11. 概率密度函数？★★

### 12. 说一下全概率公式和贝叶斯公式★★★★★★★

**条件概率**:在B发生的概率下，A发生的概率
$$
P(A|B) = \frac{P(AB)}{P(B)}
$$

**贝叶斯公式**:描述了先验概率和后验概率之间的关系。由结果推原因

先验概率:根据统计得到的概率，P(A)

后验概率:在事情已经发生后，判断由哪一个原因引起的概率

$$
P(A|B) = \frac{P(B|A)P(A)}{P(B)}
$$

**全概率公式**:将原概率的求解转化为在不同情况下的发生的简单事件的概率的求解，由原因推结果
$$
P(A) = \sum_{i = 1}^{n}P(A, B_i)\\
P(A) = \sum_{i = 1}^{n}P(A|B_i)P(B_i)
$$

### 13. 解释下相关系数. 协方差. 相关系数或协方差为0的时候能否说明两个分布无关？

### 14. 假如有一枚不均匀的 硬币，抛正面的几率是p，抛反面是1-p，请问如何做才能得出1/2？★★★

### 15. 若干正态分布相加. 相乘后得到的分布分别是什么？★★★

## 线性代数

### 特征值

**设 ![[公式]](https://www.zhihu.com/equation?tex=A) 是 ![[公式]](https://www.zhihu.com/equation?tex=n) 阶方阵，如果数 ![[公式]](https://www.zhihu.com/equation?tex=%5Clambda) 和 ![[公式]](https://www.zhihu.com/equation?tex=n+) 维非零向量 ![[公式]](https://www.zhihu.com/equation?tex=x) 使 ![[公式]](https://www.zhihu.com/equation?tex=Ax%3D%5Clambda+x) 成立，则称 ![[公式]](https://www.zhihu.com/equation?tex=%5Clambda) 是特征值， ![[公式]](https://www.zhihu.com/equation?tex=x)是对应于 ![[公式]](https://www.zhihu.com/equation?tex=%5Clambda) 的特征向量**

特征向量的意义:

### 1. 矩阵的秩,满秩代表什么？不满秩呢？★★★★★

矩阵A的不等于零的子式的最高阶数称作矩阵A的秩。

一个秩为n的矩阵满秩意味着存在一个n阶子式不为0.

不满秩的话，假设其秩为r，意味着所有大于r阶的子式都为0.

### 2. 什么是线性相关？什么是线性无关？★★★★★

对于线性空间中的n个向量，假如存在n个常数使得这n个常数与n个向量对应乘积加合等于0，则称这n个向量线性相关，如果不存在这样的n个常数，称之为线性无关。

### 3. 什么是向量空间？线性空间？★★★★(0703赵轲)

所有n维向量构成的集合称为n维向量空间。

将n维向量空间抽象化，便引出线性空间的概念。定义集合V上的两种代数运算:加法和数乘。V中任意两向量之和与V中的一个向量gamma对应；V中任意向量和域K中的任一数lambda的数乘与V中的一个向量eta对应。

并且加法满足交换律、结合律、零元、逆元，数乘存在单位元、满足结合律，数乘关于加法满足分配律。

那么这个集合V就称作线性空间，又叫向量空间。V中的元素统称为“向量“。

### 4. 什么是向量的基？★★★

n维向量空间中的n个线性无关的向量，并且空间中的其他所有向量都能被这n个向量线性表示，这n个向量就称为向量的基

### 5. 什么是向量正交？什么是矩阵正交？★★

正交向量组中，任意两个向量的数量积为0.

正交矩阵的每一列都是一个单位向量，并且任意两列求数量积都为0.

两个矩阵正交，表示这两个矩阵相乘结果为单位矩阵。

### 6. 线性方程组的解，Ax=b，Am×nAm×n分别为长矩阵和扁矩阵？怎么确定哪个解是最优解？★★★★

### 7. 什么是相似矩阵？什么是正定矩阵？★★★★

https://www.zhihu.com/question/25352258

### 8. 矩阵范数（一阶二阶范数）★★★★

### 9. 矩阵的特征值与特征向量有什么关系？特征值特征向量的含义和作用？★★★★

矩阵的特征向量是这样的向量:矩阵作用于该向量后，向量保持方向不变，进行某一比例的伸缩变换，而这个比例就是特征值。

因此，特征值与特征向量的关系就是，特征向量与特征值进行数乘操作后所得的向量，和矩阵对该向量进行变换所得向量相同。

因此特征值的含义就是和矩阵具有同等变换效果的常数，而特征向量就是与矩阵作用之后保持方向不变的向量。

作用:特征值可以用于奇异值分解、主成分分析。可以用于谱分解、特征值分解。

### 10. 矩阵运算下Ax=b中什么情况下x有解★★

## 离散数学

 https://blog.csdn.net/Sherlooock/article/details/115392090

## 机器学习

### 1. 机器学习为什么要使用概率？★★

### 1. P和NP问题

P 问题是指可以在多项式之内得到解决的问题。

NP 问题是指，某个问题的答案正确性可以在多项式时间内得到验证。

NP 完全问题是指所有 NP 问题经过推导可以得到的一个NP问题，解决它就可以解决所有 NP 问题。

NP难问题就是完全问题是指所有 NP 问题经过推导可以得到的一个问题，但这个问题不一定是NP问题，旅行商问题

![image-20220314230106386](https://gitee.com/balabala-2/images/raw/master/images/image-20220314230106386.png)

#### 随机梯度下降

### 正则化

https://www.cnblogs.com/zingp/p/10375691.html

#### 如何防止模型的过拟合

加正则化项，L1正则与L2正则

#### L1与L2有啥区别

- 数学表达式不同:参数的1范数与2范数
- L1减少的是一个常量，L2减少的是权重的固定比例
- L1使权重稀疏，L2使权重平滑
- L1优点是能够获得sparse模型，对于large-scale的问题来说这一点很重要，因为可以减少存储空间
- L2优点是实现简单，能够起到正则化的作用。缺点就是L1的优点:无法获得sparse模型

#### 为什么正则化可以防止过拟合

模型的复杂度与参数向量有关，参数越多，模型越复杂，因此可以通过让参数趋近于0或者参数等于0来达到防止过拟合的目的

#### 为什么L1正则化具有稀疏性，或者能进行特征选择，或者为什么L1正则会是参数为0

从**解空间**的形状角度，L1更可能使参数为0

从数学的角度，求梯度

https://www.zhihu.com/question/26485586

![image-20220516230832005](/Users/userli/Library/Application Support/typora-user-images/image-20220516230832005.png)

![image-20220516230841129](/Users/userli/Library/Application Support/typora-user-images/image-20220516230841129.png)

### 优化算法

### 朴素贝叶斯

https://zhuanlan.zhihu.com/p/26262151

### 自动求导的原理

https://zhuanlan.zhihu.com/p/30022887

### 梯度消失，梯度爆炸

### 梯度更新

### PCA

https://zhuanlan.zhihu.com/p/32412043

1.对所有的样本进行中心化 ![[公式]](https://www.zhihu.com/equation?tex=x_i%3Dx_i-%5Cfrac%7B1%7D%7Bm%7D%5Csum_%7Bj%3D1%7D%5E%7Bm%7Dx_j)

2.计算样本的协方差矩阵![[公式]](https://www.zhihu.com/equation?tex=C%3D%5Cfrac%7B1%7D%7Bm%7DXX%5E%5Cmathsf%7BT%7D)

3.求出协方差矩阵的特征值及对应的特征向量

4.将特征向量按对应特征值大小从上到下按行排列成矩阵，取前k行组成矩阵P

5.Y=PX即为降维到k维后的数据

### 奇异值分解

https://www.cnblogs.com/pinard/p/6251584.html

### 决策树

https://easyai.tech/ai-definition/decision-tree/
